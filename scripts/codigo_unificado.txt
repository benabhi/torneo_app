main.py

"""
Punto de Entrada Principal de la Aplicación

Este es el script que se debe ejecutar para iniciar el gestor de torneos.
Su responsabilidad es mínima pero fundamental:
1. Importar la clase principal de la interfaz gráfica (`App` desde `gui.py`).
2. Intentar cargar un ícono para la ventana.
3. Crear una instancia de la clase `App`.
4. Iniciar el bucle de eventos principal de Tkinter (`mainloop`), que pone
   en marcha la aplicación y la mantiene en ejecución.
"""

# Se importa el módulo `os` para interactuar con el sistema operativo,
# específicamente para construir rutas de archivos de manera robusta.
import os

# Se importa `PhotoImage` de Tkinter como una forma básica de cargar imágenes.
# Funciona bien con formatos como .png y .gif, pero no con .ico.
from tkinter import PhotoImage

# Se importa el módulo `gui` que contiene la clase principal `App`.
from lib import gui


# --- Manejo de Dependencia Opcional (Pillow) ---
# Se intenta importar las librerías `Image` y `ImageTk` de Pillow (PIL).
# Pillow es más potente que PhotoImage y soporta más formatos, incluyendo .ico
# en Windows, y permite un mejor manejo de transparencias.
try:
    from PIL import Image, ImageTk
    # Si la importación tiene éxito, se establece una bandera para usar Pillow.
    PIL_SUPPORT = True
except ImportError:
    # Si Pillow no está instalado, la importación falla y se establece una
    # bandera para usar la solución de respaldo (PhotoImage de Tkinter).
    PIL_SUPPORT = False


def main():
    """
    Función principal que crea y lanza la aplicación.
    """

    # 1. Crear una instancia de la aplicación.
    #    Esto ejecuta el método `__init__` de la clase `App`, que construye
    #    toda la interfaz gráfica en memoria.
    app = gui.App()

    # 2. Intentar establecer el ícono de la ventana.
    #    Este bloque está envuelto en un `try...except` para que, si falla
    #    la carga del ícono, la aplicación pueda continuar ejecutándose
    #    sin él en lugar de cerrarse con un error.
    try:
        # `os.path.abspath(__file__)` obtiene la ruta absoluta de este script.
        # `os.path.dirname(...)` obtiene el directorio que contiene el script.
        # Esto asegura que la ruta base sea correcta sin importar desde dónde
        # se ejecute el programa.
        base_path = os.path.dirname(os.path.abspath(__file__))

        # Se construye una ruta tentativa para el ícono.
        icon_path = os.path.join(base_path, 'lib', 'assets', 'icon.png')

        # Si el ícono no se encuentra en la primera ruta, se intenta buscar
        # directamente en la carpeta raíz del proyecto.
        if not os.path.exists(icon_path):
            icon_path = os.path.join(base_path, 'icon.png')

        # Si se encuentra un archivo de ícono en alguna de las rutas.
        if os.path.exists(icon_path):
            # Si se dispone de soporte de Pillow (la mejor opción).
            if PIL_SUPPORT:
                image = Image.open(icon_path)
                photo = ImageTk.PhotoImage(image)
                # `wm_iconphoto` con `True` permite usar objetos de PhotoImage complejos.
                app.wm_iconphoto(True, photo)
            # Si no, se usa la opción básica de Tkinter.
            else:
                photo = PhotoImage(file=icon_path)
                # `iconphoto` con `False` es la forma estándar de Tkinter.
                app.iconphoto(False, photo)
        # Si el archivo del ícono no se encuentra en ninguna de las rutas esperadas.
        else:
             print(f"Advertencia: No se pudo encontrar el icono de la aplicación en '{icon_path}'.")

    # Si ocurre cualquier otro error durante la carga del ícono (ej: archivo corrupto).
    except Exception as e:
        print(f"Advertencia: No se pudo cargar el icono de la aplicación.")
        print(f"Error: {e}")

    # 3. Iniciar el bucle de eventos principal de la aplicación.
    #    Esta línea es crucial. `mainloop()` pone a Tkinter en un bucle infinito
    #    donde escucha eventos (clics del ratón, pulsaciones de teclas, etc.)
    #    y actualiza la GUI en consecuencia. El programa permanecerá en esta
    #    línea hasta que el usuario cierre la ventana.
    app.mainloop()

# --- Punto de Entrada del Script ---
# Esta es una construcción estándar en Python.
# El bloque de código dentro de este `if` solo se ejecutará cuando este archivo
# (`main.py`) sea ejecutado directamente por el intérprete de Python.
# Si otro archivo importara `main.py` (ej: `import main`), este bloque
# NO se ejecutaría. Esto lo convierte en el punto de partida ideal para la aplicación.
if __name__ == "__main__":
    main()

lib\gui.py

"""
Módulo de Interfaz Gráfica (GUI) - El Corazón Visual de la Aplicación

Este archivo define la clase principal `App`, que orquesta toda la interfaz
gráfica del usuario. Hereda de `tkinter.Tk` para convertirse en la ventana
principal de la aplicación.

Su rol es actuar como el "Controlador" en un patrón similar a MVC (Modelo-Vista-Controlador):
- **Vista:** Construye y organiza todos los widgets visibles (botones, tablas, etc.).
- **Controlador:** Captura las interacciones del usuario (clics, selecciones) y
  llama a los módulos de lógica (`logic.py`) o de datos (`database.py`) para
  procesar las solicitudes. Luego, actualiza la Vista con los nuevos datos.

La estructura está dividida en tres pestañas principales, cada una manejando
una etapa del torneo, lo que guía al usuario a través de un flujo de trabajo lógico.
"""

# Se importa la librería `tkinter` completa como 'tk' para los componentes base.
import tkinter as tk
# Se importan los submódulos `ttk` (widgets modernos) y `messagebox` (ventanas emergentes).
from tkinter import ttk, messagebox
# Se importa 'random' para la funcionalidad de autogeneración de resultados.
import random

# --- Importaciones de Módulos Propios ---
# Se importan los otros componentes de la aplicación.
from . import database          # Capa de acceso a datos.
from . import logic             # Capa de reglas de negocio del torneo.
from . import widgets           # Componentes de GUI personalizados.
from . import config            # Archivo de configuración central.
from .logger import logger      # Sistema de registro de eventos.
import tkfontawesome as fa      # Librería para usar iconos en la GUI.


# --- CLASE PRINCIPAL DE LA APLICACIÓN ---
class App(tk.Tk):
    """
    La clase principal que representa la ventana de la aplicación.
    Hereda de tk.Tk y encapsula todos los widgets, la lógica de eventos
    y los métodos para actualizar la interfaz.
    """

    def __init__(self):
        """
        Constructor de la aplicación. Se ejecuta una sola vez al iniciar.
        Es responsable de configurar la ventana, inicializar variables de estado,
        cargar recursos y construir toda la jerarquía de widgets.
        """
        # Llama al constructor de la clase padre (tk.Tk) para inicializar la ventana.
        super().__init__()

        # Se registra una función de validación con Tkinter. `self.register`
        # devuelve un "wrapper" que puede ser llamado desde el intérprete Tcl interno
        # de Tkinter. Esto es necesario para que los widgets `Entry` puedan usar
        # una función de Python para su validación.
        # '%P' es un código de sustitución que le dice a Tkinter que pase el
        # valor que TENDRÁ el Entry si la edición es permitida.
        self.vcmd = (self.register(self._validar_solo_numeros), '%P')

        # --- 1. Configuración de la Ventana Principal ---
        self.title("Gestor de Torneo de Fútbol")

        # Define las dimensiones de la ventana.
        window_width = 960
        window_height = 600
        # Obtiene las dimensiones de la pantalla del usuario.
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        # Calcula las coordenadas X e Y para centrar la ventana en la pantalla.
        center_x = int(screen_width/2 - window_width / 2)
        center_y = int(screen_height/2 - window_height / 2) - 30 # Un pequeño ajuste vertical.
        # Establece la geometría y posición de la ventana.
        self.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        # Impide que el usuario pueda cambiar el tamaño de la ventana.
        self.resizable(False, False)

        # --- 2. Configuración de Estilos Gráficos (ttk.Style) ---
        # Se crea un objeto Style para personalizar la apariencia de los widgets ttk.
        style = ttk.Style(self)
        # Posiciona las pestañas del Notebook en la parte superior.
        style.configure('TNotebook', tabposition='n')
        # Define el padding y la fuente para las etiquetas de las pestañas.
        style.configure('TNotebook.Tab', padding=(30, 8), font=('Arial', 10, 'bold'))
        # Crea estilos personalizados que se usarán en widgets específicos.
        style.configure('Champion.TFrame', background='#f0f0f0', relief='solid', borderwidth=1)
        style.configure('Danger.TButton', foreground='black', background='#ffcdd2', font=('Arial', 9, 'bold'), borderwidth=1, relief='raised')
        style.map('Danger.TButton', background=[('active', '#ef9a9a')]) # Color cuando el botón está activo/presionado.
        style.configure('Test.TButton', foreground='black', background='#fff9c4', font=('Arial', 9), borderwidth=1, relief='raised')
        style.map('Test.TButton', background=[('active', '#fff59d')])
        style.configure('Content.TFrame', background='#fafafa', relief='solid', borderwidth=1)
        style.configure('Content.TLabel', background='#fafafa')

        # --- 3. Carga de Recursos (Iconos) ---
        # Se cargan todos los iconos una sola vez al inicio para optimizar el rendimiento.
        # `tkfontawesome.icon_to_image` convierte un icono de FontAwesome en un objeto de imagen de Tkinter.
        self.icon_add = fa.icon_to_image("plus-circle", fill="green", scale_to_height=16)
        self.icon_edit = fa.icon_to_image("pencil-alt", fill="#3366cc", scale_to_height=16)
        self.icon_delete = fa.icon_to_image("trash-alt", fill="#c00", scale_to_height=16)
        self.icon_delete_all = fa.icon_to_image("dumpster-fire", fill="#c00", scale_to_height=16)
        self.icon_generate = fa.icon_to_image("cogs", fill="#555", scale_to_height=16)
        self.icon_next = fa.icon_to_image("arrow-circle-right", fill="blue", scale_to_height=16)
        self.icon_reset = fa.icon_to_image("undo", fill="#c00", scale_to_height=16)
        self.icon_save = fa.icon_to_image("save", fill="blue", scale_to_height=16)
        self.icon_clear = fa.icon_to_image("broom", fill="#555", scale_to_height=16)
        self.icon_confirm = fa.icon_to_image("check-circle", fill="green", scale_to_height=16)
        self.icon_trophy = fa.icon_to_image("trophy", fill="gold", scale_to_height=16)
        self.icon_medal = fa.icon_to_image("medal", fill="royalblue", scale_to_height=24)
        self.icon_shield = fa.icon_to_image("shield-alt", fill="#888", scale_to_height=14)

        # --- 4. Inicialización de Variables de Estado de la GUI ---
        # Almacena la tupla del partido seleccionado en la lista de pendientes.
        self.partido_seleccionado = None
        # Diccionario para mantener referencias a los widgets de entrada de goles en las fases eliminatorias.
        self.entry_widgets_por_fase = {}
        # Caché para almacenar los escudos ya coloreados y evitar regenerarlos.
        self.escudos_coloreados_cache = {}
        # Diccionario para acceder rápidamente a los datos de un equipo por su nombre.
        self.equipos_data = {}
        # Lista para mantener referencias a las etiquetas de colores en la tabla de equipos, para poder borrarlas.
        self.color_labels = []

        # --- 5. Construcción de la Estructura Principal de la GUI ---
        # Se empaqueta la BARRA DE ESTADO PRIMERO para que reserve su espacio en la parte inferior.
        self.status_bar = ttk.Frame(self, relief="sunken")
        self.status_bar.pack(side="bottom", fill="x", padx=1, pady=1)

        # Etiqueta para mostrar el total de equipos. Se alinea a la izquierda.
        self.status_label_equipos = ttk.Label(self.status_bar, text="Equipos: 0", anchor="w")
        self.status_label_equipos.pack(side="left", padx=10, pady=2)

        # Etiqueta para mostrar la fase actual del torneo.
        self.status_label_fase = ttk.Label(self.status_bar, text="Fase: Configuración", anchor="w")
        self.status_label_fase.pack(side="left", padx=10, pady=2)

        # Etiqueta para mensajes de estado. Se alinea a la derecha para que no
        # se solape con las otras etiquetas.
        self.status_label_mensaje = ttk.Label(self.status_bar, text="Listo", anchor="e")
        self.status_label_mensaje.pack(side="right", padx=10, pady=2)

        # AHORA se empaqueta el NOTEBOOK, que ocupará todo el espacio restante.
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")
        self.notebook.enable_traversal() # Permite navegar entre pestañas con Ctrl+Tab.

        # Se crean los Frames (contenedores) para cada pestaña.
        self.frame_equipos = ttk.Frame(self.notebook)
        self.notebook.add(self.frame_equipos, text="1. Gestionar Equipos")
        self.frame_grupos = ttk.Frame(self.notebook)
        self.notebook.add(self.frame_grupos, text="2. Fase de Grupos")
        self.frame_eliminatorias = ttk.Frame(self.notebook)
        self.notebook.add(self.frame_eliminatorias, text="3. Fases Eliminatorias")

        # --- 6. Llamada a los Métodos Constructores de Widgets ---
        # Se llama a un método separado para construir el contenido de cada pestaña,
        # manteniendo el constructor `__init__` más limpio y organizado.
        self.crear_widgets_equipos()
        self.crear_widgets_grupos()
        self.crear_widgets_eliminatorias()

        # --- 7. Sincronización Inicial de la GUI ---
        # Llama al método que carga todos los datos iniciales y establece el estado correcto de la UI.
        self.actualizar_todas_las_vistas()

    def _validar_solo_numeros(self, P):
        """
        Función de validación utilizada por los widgets Entry de goles.

        Esta función es llamada por Tkinter cada vez que el usuario intenta
        modificar el contenido del Entry. Devuelve `True` solo si el nuevo
        contenido (`P`) es una cadena de dígitos o una cadena vacía (para
        permitir que el usuario borre el campo).

        Args:
            P (str): El valor que tendría el Entry si se permitiera la edición.

        Returns:
            bool: True para permitir el cambio, False para rechazarlo.
        """
        if str.isdigit(P) or P == "":
            return True
        return False

    def _actualizar_barra_estado(self, mensaje="Listo"):
        """
        Actualiza la información mostrada en la barra de estado inferior.

        Este método centraliza la lógica para refrescar las etiquetas de la barra
        de estado, como el número total de equipos y la fase actual del torneo.
        También permite mostrar un mensaje temporal sobre la última acción realizada.

        Args:
            mensaje (str): El mensaje a mostrar en la parte derecha de la barra.
                           Por defecto es "Listo".
        """
        # Actualiza el contador de equipos consultando la base de datos.
        total_equipos = len(database.db.obtener_equipos())
        self.status_label_equipos.config(text=f"Equipos: {total_equipos}")

        # Determina y muestra la fase actual del torneo.
        fase_actual_texto = "Configuración"
        if database.db.fase_grupos_bloqueada():
            # Aquí se podría añadir lógica más compleja para detectar la fase
            # eliminatoria específica (Cuartos, Semifinal, etc.).
            fase_actual_texto = "Fases Eliminatorias"
        elif database.db.equipos_bloqueados():
            fase_actual_texto = "Fase de Grupos"

        self.status_label_fase.config(text=f"Fase: {fase_actual_texto}")

        # Muestra el mensaje de estado pasado como argumento.
        self.status_label_mensaje.config(text=mensaje)

    def _update_ui_state(self):
        """
        Gestiona el estado de la interfaz (habilitar/deshabilitar widgets).
        Este método centraliza toda la lógica que decide qué puede hacer el
        usuario en cada momento del torneo. Se llama cada vez que ocurre una
        acción importante (agregar equipo, registrar partido, etc.).
        """
        # Obtiene el estado actual del torneo desde la base de datos.
        equipos_estan_bloqueados = database.db.equipos_bloqueados()
        grupos_estan_bloqueados = database.db.fase_grupos_bloqueada()

        # Calcula cuántos equipos hay en cada zona.
        equipos_por_zona = {zona: 0 for zona in config.ZONAS_DEL_TORNEO}
        for _, _, zona, _ in database.db.obtener_equipos():
            if zona in equipos_por_zona:
                equipos_por_zona[zona] += 1

        # Verifica si todas las zonas han alcanzado el máximo de equipos.
        todos_los_grupos_llenos = all(count == config.MAX_EQUIPOS_POR_ZONA for count in equipos_por_zona.values())

        # --- Lógica para la Pestaña "Gestionar Equipos" ---
        if hasattr(self, 'btn_agregar'):
            if equipos_estan_bloqueados:
                # Si los equipos están bloqueados, deshabilita todos los controles de edición.
                self.entry_nombre.config(state='disabled')
                self.combo_zona.config(state='disabled')
                self.btn_agregar.config(state='disabled')
                self.btn_modificar.config(state='disabled')
                self.btn_eliminar_seleccionado.config(state='disabled')
                if config.BOTONES_PRUEBA_VISIBLES: self.btn_autogen_equipos.config(state='disabled')
                self.btn_confirmar_equipos.grid_remove() # Oculta el botón de confirmar.
                self.lbl_equipos_bloqueados.grid() # Muestra el label informativo.
            else:
                # Si no están bloqueados, habilita los controles.
                self.entry_nombre.config(state='normal')
                self.combo_zona.config(state='normal')
                self.btn_modificar.config(state='normal')
                self.btn_eliminar_seleccionado.config(state='normal')
                if config.BOTONES_PRUEBA_VISIBLES: self.btn_autogen_equipos.config(state='normal')
                self.lbl_equipos_bloqueados.grid_remove() # Oculta el label.

                # Lógica para deshabilitar el botón "Agregar" si una zona está llena.
                zona_seleccionada = self.combo_zona.get()
                if zona_seleccionada:
                    num_equipos_en_zona = equipos_por_zona.get(zona_seleccionada, 0)
                    if num_equipos_en_zona >= config.MAX_EQUIPOS_POR_ZONA:
                        self.btn_agregar.config(state='disabled')
                        widgets.Tooltip(self.btn_agregar, f"La Zona '{zona_seleccionada}' está llena (máx: {config.MAX_EQUIPOS_POR_ZONA}).")
                    else:
                        self.btn_agregar.config(state='normal')
                        widgets.Tooltip(self.btn_agregar, "Añadir el equipo a la base de datos.")
                else:
                    self.btn_agregar.config(state='normal')
                    widgets.Tooltip(self.btn_agregar, "Añadir el equipo a la base de datos.")

                # Muestra el botón para confirmar y bloquear equipos solo si todas las zonas están llenas.
                if todos_los_grupos_llenos:
                    self.btn_confirmar_equipos.grid()
                else:
                    self.btn_confirmar_equipos.grid_remove()

        # Habilita o deshabilita la pestaña de Fase de Grupos.
        self.notebook.tab(1, state='normal' if equipos_estan_bloqueados else 'disabled')

        # --- Lógica para la Pestaña "Fase de Grupos" ---
        if hasattr(self, 'btn_confirmar_grupos'):
            # Verifica si quedan partidos pendientes en alguna zona.
            todos_jugados = True
            for zona in config.ZONAS_DEL_TORNEO:
                if logic.generar_fixture_zona(zona): # Si la lista no está vacía, hay pendientes.
                    todos_jugados = False
                    break

            if grupos_estan_bloqueados:
                # Deshabilita todos los widgets de la pestaña.
                for child in self.frame_grupos.winfo_children():
                    try: child.config(state='disabled')
                    except tk.TclError: pass # Ignora errores en widgets que no soportan 'state'.
                self.lbl_info_bloqueo.grid(); self.lbl_info_bloqueo.config(state='normal')
                self.btn_confirmar_grupos.grid_remove()
                self.btn_reiniciar_carga.grid_remove()
            else:
                # Habilita todos los widgets.
                for child in self.frame_grupos.winfo_children():
                    try: child.config(state='normal')
                    except tk.TclError: pass
                self.lbl_info_bloqueo.grid_remove()
                # Muestra el botón de confirmar fase solo si todos los partidos se han jugado.
                if todos_jugados and len(database.db.obtener_equipos()) > 0:
                    self.btn_confirmar_grupos.grid()
                    self.btn_reiniciar_carga.grid()
                else:
                    self.btn_confirmar_grupos.grid_remove()
                    self.btn_reiniciar_carga.grid_remove()

        # Habilita o deshabilita la pestaña de Fases Eliminatorias.
        self.notebook.tab(2, state='normal' if grupos_estan_bloqueados else 'disabled')

    def _on_zona_seleccionada(self, event=None):
        """Callback que se ejecuta cuando el usuario selecciona una zona en el Combobox."""
        self._update_ui_state()

    def crear_widgets_equipos(self):
        """Construye todos los widgets para la pestaña 'Gestionar Equipos'."""
        # --- Frame del Formulario ---
        frame_form = ttk.LabelFrame(self.frame_equipos, text="Gestión de Equipos")
        frame_form.pack(fill="x", padx=10, pady=10)
        frame_form.columnconfigure(1, weight=1) # Hace que la columna 1 (Entry) se expanda.

        ttk.Label(frame_form, text="Nombre:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        self.entry_nombre = ttk.Entry(frame_form)
        self.entry_nombre.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        self.btn_agregar = ttk.Button(frame_form, text=" Agregar", image=self.icon_add, compound="left", command=self.agregar_equipo)
        self.btn_agregar.grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        widgets.Tooltip(self.btn_agregar, "Añadir el equipo a la base de datos.")
        btn_eliminar_datos = ttk.Button(frame_form, text=" Borrar Todo", image=self.icon_delete_all, compound="left", command=self.eliminar_todos_los_datos, style='Danger.TButton')
        btn_eliminar_datos.grid(row=0, column=3, padx=15, pady=5, sticky="ew")
        widgets.Tooltip(btn_eliminar_datos, "¡CUIDADO! Borra permanentemente todos los datos.")

        ttk.Label(frame_form, text="Zona:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.combo_zona = ttk.Combobox(frame_form, values=config.ZONAS_DEL_TORNEO)
        self.combo_zona.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        self.combo_zona.bind("<<ComboboxSelected>>", self._on_zona_seleccionada)
        self.btn_modificar = ttk.Button(frame_form, text=" Modificar", image=self.icon_edit, compound="left", command=self.modificar_equipo)
        self.btn_modificar.grid(row=1, column=2, padx=5, pady=5, sticky="ew")

        # Botón de prueba, solo visible si está activado en config.py.
        if config.BOTONES_PRUEBA_VISIBLES:
            self.btn_autogen_equipos = ttk.Button(frame_form, text=" Generar Equipos", image=self.icon_generate, compound="left", command=self.autogenerar_equipos_prueba, style='Test.TButton')
            self.btn_autogen_equipos.grid(row=1, column=3, padx=15, pady=5, sticky="ew")
            widgets.Tooltip(self.btn_autogen_equipos, f"PRUEBAS!: Borra los datos y genera {config.MAX_EQUIPOS_POR_ZONA} equipos por zona.")

        # --- Frame de la Lista (Tabla) ---
        frame_lista = ttk.LabelFrame(self.frame_equipos, text="Lista de Equipos"); frame_lista.pack(fill="both", expand=True, padx=10, pady=10)
        tree_container = ttk.Frame(frame_lista); tree_container.pack(fill="both", expand=True)

        # El Treeview es el widget usado para mostrar datos en formato de tabla.
        columns = ("ID", "Nombre", "Zona", "Color")
        self.tree_equipos = ttk.Treeview(tree_container, columns=columns, show="headings")
        scrollbar_equipos = ttk.Scrollbar(tree_container, orient="vertical", command=self.tree_equipos.yview)
        self.tree_equipos.configure(yscrollcommand=scrollbar_equipos.set)

        # Configuración de las cabeceras y columnas de la tabla.
        self.tree_equipos.heading("ID", text="ID"); self.tree_equipos.column("ID", width=50, anchor="center")
        self.tree_equipos.heading("Nombre", text="Nombre")
        self.tree_equipos.heading("Zona", text="Zona"); self.tree_equipos.column("Zona", width=80, anchor="center")
        self.tree_equipos.heading("Color", text="Color"); self.tree_equipos.column("Color", width=100, anchor="center")

        scrollbar_equipos.pack(side="right", fill="y"); self.tree_equipos.pack(side="left", fill="both", expand=True)
        # Asocia el evento de selección de una fila con el método `seleccionar_equipo`.
        self.tree_equipos.bind("<<TreeviewSelect>>", self.seleccionar_equipo)

        # --- Frame para Botones Inferiores ---
        bottom_frame_lista = ttk.Frame(frame_lista)
        bottom_frame_lista.pack(fill="x", pady=5)
        bottom_frame_lista.columnconfigure(0, weight=1)

        self.btn_eliminar_seleccionado = ttk.Button(bottom_frame_lista, text=f" Eliminar Seleccionado", image=self.icon_delete, compound="left", command=self.eliminar_equipo)
        self.btn_eliminar_seleccionado.grid(row=0, column=0, sticky='w')

        self.btn_confirmar_equipos = ttk.Button(bottom_frame_lista, text=f"Confirmar Equipos ", image=self.icon_next, compound="right", command=self.confirmar_lista_equipos)
        self.btn_confirmar_equipos.grid(row=0, column=1, sticky='e')
        self.lbl_equipos_bloqueados = ttk.Label(bottom_frame_lista, text="La lista de equipos está bloqueada.", font=("Arial", 10, "italic"), foreground="blue")
        self.lbl_equipos_bloqueados.grid(row=0, column=0, columnspan=2)

        # Carga inicial de los datos en la tabla.
        self.actualizar_lista_equipos()

    def confirmar_lista_equipos(self):
        """Acción del botón 'Confirmar Equipos'. Muestra una advertencia y bloquea la edición."""
        if messagebox.askyesno("Confirmar y Bloquear", "Está a punto de bloquear la lista de equipos.\n\nDespués de esto, no podrá agregar, modificar o eliminar equipos.\n¿Desea continuar?"):
            database.db.establecer_config('equipos_bloqueados', '1')
            logger.warning("¡Lista de equipos bloqueada!")
            self.actualizar_todas_las_vistas("Lista de equipos bloqueada. Puede proceder a la Fase de Grupos.")
            messagebox.showinfo("Lista Bloqueada", "La lista de equipos ha sido bloqueada. Ahora puede proceder a la Fase de Grupos.")
            self.notebook.select(self.frame_grupos) # Cambia a la siguiente pestaña.

    def eliminar_todos_los_datos(self):
        """Acción del botón 'Borrar Todo'. Operación destructiva que reinicia el torneo."""
        if messagebox.askyesno("Confirmar Borrado Total", "¡ADVERTENCIA!\n\nEsto borrará permanentemente TODOS los equipos y partidos de la base de datos.\n\n¿Está absolutamente seguro de que desea continuar?"):
            database.db.borrar_todos_los_datos()
            logger.critical("¡TODOS LOS DATOS HAN SIDO BORRADOS POR EL USUARIO!")
            self.actualizar_todas_las_vistas("Todos los datos del torneo han sido eliminados.")
            messagebox.showinfo("Operación Completada", "Todos los datos del torneo han sido eliminados.")

    def crear_widgets_grupos(self):
        """Construye todos los widgets para la pestaña 'Fase de Grupos'."""
        # Estructura principal de la pestaña con dos columnas.
        top_frame = ttk.Frame(self.frame_grupos); top_frame.pack(fill="x", padx=10, pady=10)
        # Columna izquierda: Partidos pendientes y registro de resultados.
        frame_pendientes = ttk.LabelFrame(top_frame, text="Partidos Pendientes"); frame_pendientes.pack(side="left", fill="both", expand=True, padx=(0, 5))
        control_frame = ttk.Frame(frame_pendientes); control_frame.pack(fill="x", padx=5, pady=5)
        control_frame.columnconfigure(1, weight=1)
        ttk.Label(control_frame, text="Seleccionar Zona:").grid(row=0, column=0, sticky="w")
        self.combo_zona_partidos = ttk.Combobox(control_frame, values=config.ZONAS_DEL_TORNEO); self.combo_zona_partidos.grid(row=0, column=1, sticky="ew", padx=5)
        self.combo_zona_partidos.bind("<<ComboboxSelected>>", self.cargar_partidos_pendientes)
        self.tree_pendientes_container = ttk.Frame(frame_pendientes)
        self.tree_pendientes_container.pack(fill="both", expand=True, pady=5, padx=5)
        self.msg_no_pendientes = ttk.Label(frame_pendientes, text="Todos los partidos de esta zona han sido jugados.", font=("Arial", 10, "italic"), anchor="center")
        self.tree_partidos_pendientes = self._crear_tabla_partidos_pendientes(self.tree_pendientes_container)
        self.tree_partidos_pendientes.bind("<<TreeviewSelect>>", self.seleccionar_partido)
        # Columna derecha: Formulario para ingresar goles.
        frame_registro = ttk.LabelFrame(top_frame, text="Registrar Resultado"); frame_registro.pack(side="right", fill="y", padx=(5, 0))
        frame_registro.columnconfigure((0, 2), weight=1); frame_registro.rowconfigure((0, 2, 4), weight=1)
        self.lbl_local = ttk.Label(frame_registro, text="Seleccione un partido", font=("Arial", 10, "bold")); self.lbl_local.grid(row=0, column=0, columnspan=3, pady=(10,0))

        # Se añaden las opciones `validate` y `validatecommand` a los Entry de goles.
        # `validate='key'` significa que la validación se dispara con cada pulsación de tecla.
        # `validatecommand` se asocia con el comando registrado en __init__.
        self.entry_goles_local = ttk.Entry(frame_registro, width=5, justify='center',
                                           validate='key', validatecommand=self.vcmd)
        self.entry_goles_local.grid(row=1, column=0, sticky='e', padx=(10,0))
        ttk.Label(frame_registro, text="vs").grid(row=1, column=1, padx=5)
        self.entry_goles_visitante = ttk.Entry(frame_registro, width=5, justify='center',
                                               validate='key', validatecommand=self.vcmd)
        self.entry_goles_visitante.grid(row=1, column=2, sticky='w', padx=(0,10))

        self.lbl_visitante = ttk.Label(frame_registro, text="", font=("Arial", 10, "bold")); self.lbl_visitante.grid(row=2, column=0, columnspan=3)
        btn_frame = ttk.Frame(frame_registro); btn_frame.grid(row=3, column=0, columnspan=3, pady=(0,10))
        self.btn_guardar_resultado_grupo = ttk.Button(btn_frame, text=" Guardar", image=self.icon_save, compound="left", command=self.registrar_partido_grupo)
        self.btn_guardar_resultado_grupo.pack(side="left", padx=5)
        self.btn_limpiar_formulario = ttk.Button(btn_frame, text=" Limpiar", image=self.icon_clear, compound="left", command=self._limpiar_formulario_partido)
        self.btn_limpiar_formulario.pack(side="left", padx=5)

        # Botón de prueba para autogenerar resultados.
        if config.BOTONES_PRUEBA_VISIBLES:
            self.btn_autogen_res = ttk.Button(self.frame_grupos, text=" Generar Resultados", image=self.icon_generate, compound="left", command=self.autogenerar_resultados_prueba, style='Test.TButton')
            self.btn_autogen_res.pack(pady=5, fill="x", padx=10)
            widgets.Tooltip(self.btn_autogen_res, "PRUEBAS!: Registra resultados aleatorios para todos los partidos\nde la fase de grupos que estén pendientes.")

        # Tabla de posiciones que ocupa la parte inferior de la pestaña.
        frame_tabla = ttk.LabelFrame(self.frame_grupos, text="Tabla de Posiciones General"); frame_tabla.pack(fill="both", expand=True, padx=10, pady=10)
        tree_pos_container = ttk.Frame(frame_tabla); tree_pos_container.pack(fill="both", expand=True, padx=5, pady=5)
        cols = ("Zona", "Equipo", "PJ", "PG", "PE", "PP", "GF", "GC", "DG", "Puntos")
        self.tree_posiciones = ttk.Treeview(tree_pos_container, columns=cols, show="headings")
        scrollbar_posiciones = ttk.Scrollbar(tree_pos_container, orient="vertical", command=self.tree_posiciones.yview)
        self.tree_posiciones.configure(yscrollcommand=scrollbar_posiciones.set)

        for col in cols:
            # Asocia un comando a cada cabecera para permitir ordenar la tabla.
            self.tree_posiciones.heading(col, text=col, command=lambda c=col: self.ordenar_tabla_posiciones(c, False))
            width = 80 if col not in ["Equipo"] else 150
            self.tree_posiciones.column(col, width=width, anchor="center")

        scrollbar_posiciones.pack(side="right", fill="y"); self.tree_posiciones.pack(side="left", fill="both", expand=True)

        # Botones inferiores de la pestaña.
        bottom_frame = ttk.Frame(self.frame_grupos); bottom_frame.pack(fill="x")
        bottom_frame.columnconfigure((0,1), weight=1)
        self.btn_reiniciar_carga = ttk.Button(bottom_frame, text=f" Reiniciar Resultados", image=self.icon_reset, compound="left", command=self.reiniciar_carga_resultados, style='Danger.TButton')
        self.btn_reiniciar_carga.grid(row=0, column=0, padx=10, pady=10, sticky="w")
        self.btn_confirmar_grupos = ttk.Button(bottom_frame, text=f"Confirmar Fase ", image=self.icon_next, compound="right", command=self.confirmar_fase_grupos)
        self.btn_confirmar_grupos.grid(row=0, column=1, padx=10, pady=10, sticky="e")
        self.lbl_info_bloqueo = ttk.Label(bottom_frame, text="La fase de grupos está bloqueada.", font=("Arial", 10, "italic"), foreground="blue")
        self.lbl_info_bloqueo.grid(row=0, column=0, columnspan=2)

        self.actualizar_tablas()

    def ordenar_tabla_posiciones(self, col, reverse):
        """Ordena la tabla de posiciones por la columna clickeada."""
        # Obtiene todos los datos de la tabla.
        data = [(self.tree_posiciones.set(item, col), item) for item in self.tree_posiciones.get_children('')]

        # Intenta ordenar numéricamente, si falla, ordena alfabéticamente.
        try:
            data.sort(key=lambda x: int(x[0]), reverse=reverse)
        except ValueError:
            data.sort(key=lambda x: x[0], reverse=reverse)

        # Mueve las filas en la tabla a su nueva posición ordenada.
        for index, (val, item) in enumerate(data):
            self.tree_posiciones.move(item, '', index)

        # Vuelve a asociar el comando a la cabecera, pero invirtiendo el orden
        # para que el siguiente clic ordene en la dirección opuesta.
        self.tree_posiciones.heading(col, command=lambda: self.ordenar_tabla_posiciones(col, not reverse))
        logger.debug(f"Tabla de posiciones ordenada por '{col}' en orden {'descendente' if reverse else 'ascendente'}.")

    def _crear_tabla_partidos_pendientes(self, parent):
        """Función auxiliar para crear una tabla (Treeview) de partidos."""
        cols = ("Local", "Visitante")
        tree = ttk.Treeview(parent, columns=cols, show="headings")
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        tree.heading("Local", text="Equipo Local"); tree.column("Local", anchor="e")
        tree.heading("Visitante", text="Equipo Visitante"); tree.column("Visitante", anchor="w")
        scrollbar.pack(side="right", fill="y"); tree.pack(side="left", fill="both", expand=True)
        return tree

    def confirmar_fase_grupos(self):
        """Acción del botón 'Confirmar Fase'. Bloquea la carga de resultados."""
        if messagebox.askyesno("Confirmar y Bloquear", "Está a punto de bloquear la fase de grupos.\n\nDespués de esto, no podrá registrar nuevos resultados.\n¿Desea continuar?"):
            database.db.establecer_config('fase_grupos_bloqueada', '1')
            logger.warning("¡Fase de grupos bloqueada!")
            self.actualizar_todas_las_vistas("Fase de grupos bloqueada. Puede generar las fases eliminatorias.")
            self._actualizar_vista_eliminatorias()
            messagebox.showinfo("Fase Bloqueada", "La fase de grupos ha sido bloqueada. Ahora puede generar las fases eliminatorias.")
            self.notebook.select(self.frame_eliminatorias)

    def reiniciar_carga_resultados(self):
        """Acción del botón 'Reiniciar Resultados'. Borra todos los partidos de grupos."""
        if messagebox.askyesno("Reiniciar Resultados", "Esto borrará TODOS los resultados de la fase de grupos.\nLos equipos no serán eliminados.\n\n¿Desea continuar?"):
            database.db.reiniciar_fase_grupos()
            self.actualizar_todas_las_vistas("Resultados de la fase de grupos eliminados.")
            messagebox.showinfo("Resultados Eliminados", "Todos los resultados de la fase de grupos han sido eliminados.")

    def reiniciar_fases_eliminatorias(self):
        """Acción del botón 'Reiniciar Eliminatorias'. Borra todos los partidos de las fases de playoffs."""
        if messagebox.askyesno("Confirmar Reinicio de Eliminatorias", "¡ADVERTENCIA!\n\nEsto borrará TODOS los resultados de las fases eliminatorias (Octavos, Cuartos, etc.).\nLa fase de grupos no se verá afectada.\n\n¿Desea continuar?"):
            database.db.reiniciar_fases_eliminatorias()
            self.actualizar_todas_las_vistas("Fases eliminatorias reiniciadas.")
            messagebox.showinfo("Operación Completada", "Todos los resultados de las fases eliminatorias han sido eliminados.")

    def autogenerar_equipos_prueba(self):
        """Acción del botón 'Generar Equipos'. Llena el torneo con datos de prueba."""
        if not messagebox.askyesno("Confirmar Autogeneración", "Esto borrará todos los datos existentes y generará equipos de prueba basados en la configuración actual."): return
        logger.info("Iniciando autogeneración de equipos de prueba.")
        database.db.borrar_todos_los_datos()

        equipos_por_zona_requeridos = config.MAX_EQUIPOS_POR_ZONA
        contador_equipo = 1
        for zona in config.ZONAS_DEL_TORNEO:
            for i in range(equipos_por_zona_requeridos):
                nombre_equipo = f"Equipo-{contador_equipo:02d}"
                database.db.agregar_equipo(nombre_equipo, zona)
                contador_equipo += 1

        self.actualizar_todas_las_vistas(f"Se generaron {contador_equipo - 1} equipos de prueba.")
        logger.info("Finalizada la autogeneración de equipos.")
        messagebox.showinfo("Éxito", f"Se han generado {contador_equipo - 1} equipos de prueba.")

    def actualizar_todas_las_vistas(self, mensaje="Listo"):
        """Método central para refrescar toda la información de la GUI."""
        zona_seleccionada_actualmente = self.combo_zona_partidos.get()

        self.actualizar_lista_equipos()

        if config.ZONAS_DEL_TORNEO:
            if zona_seleccionada_actualmente in config.ZONAS_DEL_TORNEO:
                self.combo_zona_partidos.set(zona_seleccionada_actualmente)
            else:
                self.combo_zona_partidos.set(config.ZONAS_DEL_TORNEO[0])

        self.cargar_partidos_pendientes()
        self.actualizar_tablas()
        self._actualizar_vista_eliminatorias()
        self._update_ui_state()
        self._actualizar_barra_estado(mensaje)

    def agregar_equipo(self):
        """Acción del botón 'Agregar'. Valida la entrada y llama a la base de datos."""
        # Obtiene los datos de los widgets, eliminando espacios en blanco del nombre.
        nombre = self.entry_nombre.get().strip()
        zona = self.combo_zona.get()
        # Valida que los campos no estén vacíos.
        if nombre and zona:
            exito = database.db.agregar_equipo(nombre, zona)
            if exito:
                # Si tuvo éxito, actualiza la tabla, limpia el formulario y actualiza el estado.
                self.actualizar_lista_equipos()
                self.entry_nombre.delete(0, tk.END)
                self._update_ui_state()
                self._actualizar_barra_estado(f"Equipo '{nombre}' agregado exitosamente.")
            else:
                # Si falló (equipo duplicado), muestra un error.
                messagebox.showerror("Error de Duplicado", f"El equipo '{nombre}' ya existe. Por favor, elija otro nombre.")
        else:
            # Si los campos estaban vacíos, muestra una advertencia.
            messagebox.showwarning("Campos vacíos", "Debe ingresar un nombre y seleccionar una zona.")

    def seleccionar_equipo(self, event):
        """Callback que se ejecuta al seleccionar una fila en la tabla de equipos."""
        selected_item = self.tree_equipos.selection()
        if not selected_item: return
        item_values = self.tree_equipos.item(selected_item, "values")
        # Rellena el formulario de edición con los datos del equipo seleccionado.
        self.entry_nombre.delete(0, tk.END); self.entry_nombre.insert(0, item_values[1])
        self.combo_zona.set(item_values[2])
        self._on_zona_seleccionada()

    def modificar_equipo(self):
        """Acción del botón 'Modificar'. Actualiza un equipo existente."""
        selected_item = self.tree_equipos.selection()
        if not selected_item:
            messagebox.showwarning("Sin selección", "Debe seleccionar un equipo para modificar.")
            return
        item = self.tree_equipos.item(selected_item)
        equipo_id = item['values'][0]
        nombre_original = item['values'][1]
        nuevo_nombre = self.entry_nombre.get().strip()
        nueva_zona = self.combo_zona.get()
        if nuevo_nombre and nueva_zona:
            exito = database.db.actualizar_equipo(equipo_id, nuevo_nombre, nueva_zona)
            if exito:
                self.actualizar_lista_equipos()
                self.entry_nombre.delete(0, tk.END)
                self.actualizar_todas_las_vistas(f"Equipo '{nombre_original}' actualizado a '{nuevo_nombre}'.")
            else:
                messagebox.showerror("Error de Duplicado", f"El nombre '{nuevo_nombre}' ya está en uso. Por favor, elija otro nombre.")
        else:
            messagebox.showwarning("Campos vacíos", "Debe ingresar un nuevo nombre y zona.")

    def eliminar_equipo(self):
        """Acción del botón 'Eliminar Seleccionado'."""
        selected_item = self.tree_equipos.selection()
        if not selected_item:
            messagebox.showwarning("Sin selección", "Debe seleccionar un equipo para eliminar.")
            return
        item = self.tree_equipos.item(selected_item)
        equipo_id = item['values'][0]
        nombre_equipo = item['values'][1]
        if messagebox.askyesno("Confirmar", f"¿Está seguro de que desea eliminar al equipo {nombre_equipo}?"):
            database.db.eliminar_equipo(equipo_id)
            self.actualizar_lista_equipos()
            self._update_ui_state()
            self._actualizar_barra_estado(f"Equipo '{nombre_equipo}' eliminado.")

    def actualizar_lista_equipos(self):
        """Refresca la tabla de equipos con los datos actuales de la base de datos."""
        # Limpia cualquier widget de color que exista.
        for label in self.color_labels:
            label.destroy()
        self.color_labels.clear()
        # Borra todas las filas existentes en la tabla.
        for i in self.tree_equipos.get_children():
            self.tree_equipos.delete(i)
        # Vuelve a insertar una fila por cada equipo de la base de datos.
        for i, (equipo_id, nombre, zona, color) in enumerate(database.db.obtener_equipos()):
            self.tree_equipos.insert("", "end", iid=equipo_id, values=(equipo_id, nombre, zona, ""))
        # `update_idletasks` fuerza a la GUI a redibujarse para que las coordenadas de las celdas estén disponibles.
        self.update_idletasks()
        # Llama a la función que dibuja los cuadros de colores sobre la tabla.
        self._render_color_boxes()

    def _render_color_boxes(self):
        """Dibuja los cuadros de color en la columna 'Color' de la tabla de equipos."""
        # Limpia los cuadros de color anteriores.
        for label in self.color_labels:
            label.destroy()
        self.color_labels.clear()
        # Oculta la columna de color si está deshabilitado en la configuración.
        if not config.ESCUDOS_VISIBLES:
            self.tree_equipos['displaycolumns'] = ("ID", "Nombre", "Zona")
            return
        else:
            self.tree_equipos['displaycolumns'] = ("ID", "Nombre", "Zona", "Color")

        # Itera sobre cada fila visible de la tabla.
        for item_id in self.tree_equipos.get_children():
            try:
                # Obtiene las coordenadas y tamaño de la celda de la columna "Color".
                bbox = self.tree_equipos.bbox(item_id, column="Color")
                if not bbox: continue
                x, y, width, height = bbox
                # Busca los datos del equipo correspondiente a esta fila.
                equipo = next((e for e in database.db.obtener_equipos() if e[0] == int(item_id)), None)
                if equipo:
                    color = equipo[3]
                    # Crea una nueva etiqueta (Label) con el color de fondo del equipo.
                    color_label = tk.Label(self.tree_equipos, background=color, relief="raised", borderwidth=1)
                    # `place` posiciona la etiqueta exactamente sobre la celda, creando la ilusión de una celda coloreada.
                    color_label.place(x=x, y=y, width=width, height=height)
                    self.color_labels.append(color_label)
            except Exception:
                # Ignora errores que puedan ocurrir si la ventana se está redibujando.
                pass

    def autogenerar_resultados_prueba(self):
        """Acción del botón 'Generar Resultados'. Registra resultados aleatorios."""
        if not messagebox.askyesno("Confirmar Autogeneración", "Esto generará resultados aleatorios para TODOS los partidos de grupo pendientes.\n¿Desea continuar?"): return
        logger.info("Iniciando autogeneración de resultados de prueba.")
        todos_pendientes = []
        for zona in config.ZONAS_DEL_TORNEO:
            todos_pendientes.extend(logic.generar_fixture_zona(zona))
        if not todos_pendientes:
            messagebox.showinfo("Información", "No hay partidos de grupo pendientes para generar.")
            return
        equipos_map = {nombre: id for id, nombre, zona, color in database.db.obtener_equipos()}
        for local_nombre, visitante_nombre in todos_pendientes:
            goles_local, goles_visitante = random.randint(0, 5), random.randint(0, 5)
            local_id, visitante_id = equipos_map.get(local_nombre), equipos_map.get(visitante_nombre)
            if local_id and visitante_id: database.db.registrar_partido("Grupo", local_id, visitante_id, goles_local, goles_visitante)
        logger.info("Finalizada la autogeneración de resultados.")
        messagebox.showinfo("Éxito", f"Se han generado y registrado los resultados de {len(todos_pendientes)} partidos.")
        self.actualizar_todas_las_vistas(f"Generados {len(todos_pendientes)} resultados de prueba.")

    def cargar_partidos_pendientes(self, event=None):
        """Carga la lista de partidos pendientes para la zona seleccionada."""
        zona = self.combo_zona_partidos.get()
        # Limpia la tabla.
        for i in self.tree_partidos_pendientes.get_children():
            self.tree_partidos_pendientes.delete(i)
        # Pide a la capa de lógica el fixture.
        pendientes = logic.generar_fixture_zona(zona) if zona else []
        # Rellena la tabla.
        for p in pendientes:
            self.tree_partidos_pendientes.insert("", "end", values=p)
        # Muestra un mensaje si no hay partidos pendientes.
        if not pendientes and zona:
            self.tree_pendientes_container.pack_forget()
            self.msg_no_pendientes.pack(fill="both", expand=True)
        else:
            self.msg_no_pendientes.pack_forget()
            self.tree_pendientes_container.pack(fill="both", expand=True, pady=5, padx=5)
        self._update_ui_state()

    def seleccionar_partido(self, event):
        """Callback al seleccionar un partido de la lista de pendientes."""
        selected_item = self.tree_partidos_pendientes.selection()
        if not selected_item: return
        local, visitante = self.tree_partidos_pendientes.item(selected_item)['values']
        # Almacena el partido seleccionado y actualiza el formulario de registro.
        self.partido_seleccionado = (local, visitante)
        self.lbl_local.config(text=local)
        self.lbl_visitante.config(text=visitante)

    def registrar_partido_grupo(self):
        """Acción del botón 'Guardar' resultado de un partido de grupo."""
        if not self.partido_seleccionado:
            messagebox.showerror("Error", "Debe seleccionar un partido de la lista.")
            return
        goles_local_str, goles_visitante_str = self.entry_goles_local.get(), self.entry_goles_visitante.get()
        if not goles_local_str or not goles_visitante_str:
            messagebox.showerror("Error", "Debe ingresar los goles para ambos equipos.")
            return
        try:
            goles_local, goles_visitante = int(goles_local_str), int(goles_visitante_str)
        except ValueError:
            # Este error ahora es menos probable gracias a la validación proactiva,
            # pero se mantiene como una segunda capa de seguridad.
            messagebox.showerror("Error", "Los goles deben ser números enteros.")
            return
        local_nombre, visitante_nombre = self.partido_seleccionado
        equipos_map = {e[1]: e[0] for e in database.db.obtener_equipos()}
        local_id, visitante_id = equipos_map.get(local_nombre), equipos_map.get(visitante_nombre)
        database.db.registrar_partido("Grupo", local_id, visitante_id, goles_local, goles_visitante)
        self._limpiar_formulario_partido()
        self.actualizar_todas_las_vistas(f"Resultado guardado: {local_nombre} {goles_local} - {goles_visitante} {visitante_nombre}.")

    def _limpiar_formulario_partido(self, event=None):
        """Limpia y resetea el formulario de registro de resultados."""
        self.partido_seleccionado = None
        self.lbl_local.config(text="Seleccione un partido")
        self.lbl_visitante.config(text="")
        self.entry_goles_local.delete(0, tk.END)
        self.entry_goles_visitante.delete(0, tk.END)
        if hasattr(self, 'tree_partidos_pendientes') and self.tree_partidos_pendientes.winfo_exists():
            if self.tree_partidos_pendientes.selection():
                self.tree_partidos_pendientes.selection_remove(self.tree_partidos_pendientes.selection())
        return "break"

    def actualizar_tablas(self):
        """Refresca la tabla de posiciones con los datos actuales."""
        if hasattr(self, 'tree_posiciones') and self.tree_posiciones.winfo_exists():
            for i in self.tree_posiciones.get_children():
                self.tree_posiciones.delete(i)
            for zona in config.ZONAS_DEL_TORNEO:
                tabla = database.db.calcular_tabla_posiciones(zona)
                for equipo in tabla:
                    self.tree_posiciones.insert("", "end", values=(zona,) + tuple(equipo.values()))
            self.ordenar_tabla_posiciones("Puntos", True)

    def crear_widgets_eliminatorias(self):
        """Construye la estructura base para la pestaña de 'Fases Eliminatorias'."""

        # El contenedor principal ahora alojará el área de scroll y el botón inferior.
        main_container = ttk.Frame(self.frame_eliminatorias)
        main_container.pack(fill="both", expand=True)

        # Se crea un frame inferior para el botón, que no se desplazará con el scroll.
        bottom_controls_frame = ttk.Frame(main_container)
        bottom_controls_frame.pack(side="bottom", fill="x", padx=10, pady=(5, 10))

        # Se crea el botón de reinicio y se guarda como un atributo de la instancia
        # para poder mostrarlo u ocultarlo dinámicamente.
        self.btn_reiniciar_eliminatorias = ttk.Button(
            bottom_controls_frame,
            text=" Reiniciar Eliminatorias",
            image=self.icon_reset,
            compound="left",
            command=self.reiniciar_fases_eliminatorias,
            style='Danger.TButton'
        )
        # La visibilidad del botón se gestionará en `_actualizar_vista_eliminatorias`.

        # El área de scroll (Canvas) ahora se empaqueta en la parte superior,
        # ocupando todo el espacio restante.
        canvas_container = ttk.Frame(main_container)
        canvas_container.pack(side="top", fill="both", expand=True)

        canvas = tk.Canvas(canvas_container)
        scrollbar = ttk.Scrollbar(canvas_container, orient="vertical", command=canvas.yview)

        self.scrollable_frame = ttk.Frame(canvas)
        def _on_canvas_configure(event):
            canvas.itemconfig(canvas_window, width=event.width)
        canvas_window = canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.bind("<Configure>", _on_canvas_configure)
        self.scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        self.fases_container = self.scrollable_frame

    def _actualizar_vista_eliminatorias(self):
        """
        Renderiza dinámicamente el cuadro de eliminatorias.
        Borra todo el contenido anterior y lo reconstruye basado en el estado
        actual del torneo, mostrando fases jugadas, la fase activa o el campeón.
        """
        # Limpia el contenedor.
        for widget in self.fases_container.winfo_children():
            widget.destroy()

        # Carga los datos de los equipos para tener acceso a sus colores.
        self.equipos_data = {nombre: {'id': id, 'zona': zona, 'color': color} for id, nombre, zona, color in database.db.obtener_equipos()}

        # Lógica para determinar el orden y nombre de las fases.
        total_clasificados = len(config.ZONAS_DEL_TORNEO) * config.EQUIPOS_CLASIFICAN_POR_ZONA
        fases_map = {16: "Octavos", 8: "Cuartos", 4: "Semifinal", 2: "Final"}

        fases_ordenadas = []
        num_equipos = total_clasificados
        while num_equipos >= 2:
            if num_equipos in fases_map:
                fases_ordenadas.append(fases_map[num_equipos])
            num_equipos //= 2

        # Se comprueba si existe algún partido de eliminatorias para decidir si se
        # muestra el botón de reinicio.
        hay_partidos_eliminatorios = False
        for fase in fases_ordenadas:
            if database.db.obtener_partidos_fase(fase):
                hay_partidos_eliminatorios = True
                break

        # Se muestra u oculta el botón basado en la bandera.
        if hay_partidos_eliminatorios:
            self.btn_reiniciar_eliminatorias.pack(side="left")
        else:
            self.btn_reiniciar_eliminatorias.pack_forget()

        # Si la final ya se jugó, muestra al campeón.
        partidos_final = database.db.obtener_partidos_fase("Final")
        if partidos_final and len(partidos_final) >= 1:
             self._mostrar_campeon()

        fase_activa_encontrada = False
        # Itera a través de las fases en orden (Octavos, Cuartos...).
        for i, fase in enumerate(fases_ordenadas):
            partidos_jugados = database.db.obtener_partidos_fase(fase)
            if partidos_jugados:
                # Si la fase ya tiene partidos, la muestra como "jugada" y colapsada.
                frame_fase = widgets.CollapsibleFrame(self.fases_container, text=f"{fase} de Final - Jugado", expanded=False)
                frame_fase.pack(fill="x", padx=10, pady=5, expand=True)
                ttk.Separator(self.fases_container, orient='horizontal').pack(fill='x', padx=10, pady=5)
                self._configurar_grid_fase(frame_fase.container)
                for j, (_, local, visitante, goles_l, goles_v) in enumerate(partidos_jugados):
                    self._crear_widget_partido_jugado(frame_fase.container, j, local, visitante, goles_l, goles_v, len(partidos_jugados))
            else:
                # Si encuentra una fase sin partidos, esa es la fase activa.
                fase_anterior = fases_ordenadas[i-1] if i > 0 else "Grupo"
                if database.db.fase_grupos_bloqueada():
                    self._generar_y_mostrar_fase(fase, fase_anterior)
                    fase_activa_encontrada = True
                break # Detiene el bucle, no muestra fases futuras.

        # Si no se encontró ninguna fase activa (porque no se ha generado la primera), muestra el botón para generarla.
        nombre_fase_inicial = fases_ordenadas[0] if fases_ordenadas else ""
        if not fase_activa_encontrada and not database.db.obtener_partidos_fase(nombre_fase_inicial) and database.db.fase_grupos_bloqueada():
             self.btn_generar_octavos = ttk.Button(self.fases_container, text=f" Generar {nombre_fase_inicial} de Final", image=self.icon_generate, compound="left", command=self._generar_y_mostrar_fase_inicial)
             self.btn_generar_octavos.pack(pady=10, padx=10)

    def _generar_y_mostrar_fase_inicial(self):
        """Acción del botón 'Generar Octavos'. Simplemente refresca la vista."""
        self._actualizar_vista_eliminatorias()

    def _generar_y_mostrar_fase(self, fase, fase_anterior):
        """Genera y muestra los widgets para la fase eliminatoria activa."""
        enfrentamientos = []
        if fase_anterior == 'Grupo':
            enfrentamientos = logic.generar_enfrentamientos_iniciales()
            if enfrentamientos is None:
                messagebox.showerror("Error de Clasificación", "No se pudieron generar los enfrentamientos. Verifique que todas las zonas tengan suficientes equipos y resultados.")
                return
        else:
            enfrentamientos = logic.generar_enfrentamientos(fase_anterior)

        frame_fase = widgets.CollapsibleFrame(self.fases_container, text=f"{fase} de Final")
        frame_fase.pack(fill="x", padx=10, pady=5, expand=True)
        ttk.Separator(self.fases_container, orient='horizontal').pack(fill='x', padx=10, pady=5)
        self._configurar_grid_fase(frame_fase.container)

        if not enfrentamientos:
            return

        self.entry_widgets_por_fase[fase] = []
        for i, (local, visitante) in enumerate(enfrentamientos):
            self._crear_widget_partido_editable(frame_fase.container, i, local, visitante)
            if i < len(enfrentamientos) - 1:
                ttk.Separator(frame_fase.container, orient='horizontal').grid(row=2 * i + 1, column=0, columnspan=5, sticky='ew', pady=8)

        ttk.Button(frame_fase.container, text=f" Registrar Todos los Partidos de {fase}", image=self.icon_confirm, compound="left", command=lambda f=fase: self.registrar_fase_completa(f)).grid(row=2 * len(enfrentamientos), columnspan=5, pady=10)

    def _crear_widget_partido_jugado(self, parent, row_index, local, visitante, goles_l, goles_v, total_partidos):
        """Crea la fila de un partido ya jugado, mostrando el resultado y coloreando al ganador."""
        row = 2 * row_index
        font_normal = ("Arial", 10); font_bold = ("Arial", 10, "bold")
        color_winner, color_loser = "green", "red"
        # Determina los estilos (fuente y color) para el ganador y el perdedor.
        if goles_l > goles_v:
            color_local, font_local = color_winner, font_bold
            color_visitante, font_visitante = color_loser, font_normal
        elif goles_v > goles_l:
            color_local, font_local = color_loser, font_normal
            color_visitante, font_visitante = color_winner, font_bold
        else: # Empate (aunque no debería ocurrir en eliminatorias)
            color_local, font_local = "black", font_normal
            color_visitante, font_visitante = "black", font_normal

        # Si los escudos están habilitados, los muestra junto al nombre.
        if config.ESCUDOS_VISIBLES:
            color_local_escudo = self.equipos_data.get(local, {}).get('color', '#888888')
            color_visitante_escudo = self.equipos_data.get(visitante, {}).get('color', '#888888')
            # Usa un caché para no regenerar la imagen del escudo si ya se creó.
            if local not in self.escudos_coloreados_cache: self.escudos_coloreados_cache[local] = fa.icon_to_image("shield-alt", fill=color_local_escudo, scale_to_height=14)
            if visitante not in self.escudos_coloreados_cache: self.escudos_coloreados_cache[visitante] = fa.icon_to_image("shield-alt", fill=color_visitante_escudo, scale_to_height=14)
            img_local, img_visitante = self.escudos_coloreados_cache[local], self.escudos_coloreados_cache[visitante]
            tk.Label(parent, text=f"{local} ", image=img_local, compound="right", anchor="e", font=font_normal, background="#fafafa").grid(row=row, column=0, sticky="ew", padx=5)
            tk.Label(parent, text=f" {visitante}", image=img_visitante, compound="left", anchor="w", font=font_normal, background="#fafafa").grid(row=row, column=4, sticky="ew", padx=5)
        else: # Si no, solo muestra el texto del nombre.
            tk.Label(parent, text=local, anchor="e", font=font_normal, background="#fafafa").grid(row=row, column=0, sticky="ew", padx=5)
            tk.Label(parent, text=visitante, anchor="w", font=font_normal, background="#fafafa").grid(row=row, column=4, sticky="ew", padx=5)

        # Muestra los goles con el estilo (color/fuente) determinado.
        tk.Label(parent, text=str(goles_l), anchor="center", font=font_local, fg=color_local, width=4, background="#fafafa").grid(row=row, column=1, padx=2)
        tk.Label(parent, text="-", anchor="center", font=font_normal, background="#fafafa").grid(row=row, column=2)
        tk.Label(parent, text=str(goles_v), anchor="center", font=font_visitante, fg=color_visitante, width=4, background="#fafafa").grid(row=row, column=3, padx=2)

        # Añade un separador visual entre los partidos.
        if row_index < total_partidos - 1:
            ttk.Separator(parent, orient='horizontal').grid(row=row + 1, column=0, columnspan=5, sticky='ew', pady=8)

    def _crear_widget_partido_editable(self, parent, row_index, local, visitante):
        """Crea la fila de un partido pendiente de jugar, con campos de entrada para los goles."""
        row = 2 * row_index
        if config.ESCUDOS_VISIBLES:
            color_local_escudo = self.equipos_data.get(local, {}).get('color', '#888888')
            color_visitante_escudo = self.equipos_data.get(visitante, {}).get('color', '#888888')
            if local not in self.escudos_coloreados_cache: self.escudos_coloreados_cache[local] = fa.icon_to_image("shield-alt", fill=color_local_escudo, scale_to_height=14)
            if visitante not in self.escudos_coloreados_cache: self.escudos_coloreados_cache[visitante] = fa.icon_to_image("shield-alt", fill=color_visitante_escudo, scale_to_height=14)
            img_local, img_visitante = self.escudos_coloreados_cache[local], self.escudos_coloreados_cache[visitante]
            ttk.Label(parent, text=f"{local} ", image=img_local, compound="right", style='Content.TLabel').grid(row=row, column=0, sticky="e", padx=5)
            ttk.Label(parent, text=f" {visitante}", image=img_visitante, compound="left", style='Content.TLabel').grid(row=row, column=4, sticky="w", padx=5)
        else:
            ttk.Label(parent, text=local, anchor="e", style='Content.TLabel').grid(row=row, column=0, sticky="ew", padx=5)
            ttk.Label(parent, text=visitante, anchor="w", style='Content.TLabel').grid(row=row, column=4, sticky="ew", padx=5)

        # Se reutiliza el mismo comando de validación para estos Entrys dinámicos.
        goles_local = ttk.Entry(parent, width=4, justify="center",
                                validate='key', validatecommand=self.vcmd)
        goles_local.grid(row=row, column=1, padx=2)
        ttk.Label(parent, text="vs", style='Content.TLabel').grid(row=row, column=2)
        goles_visitante = ttk.Entry(parent, width=4, justify="center",
                                    validate='key', validatecommand=self.vcmd)

        goles_visitante.grid(row=row, column=3, padx=2)

        # Guarda una referencia a los widgets de entrada para poder leer sus valores más tarde.
        fase_actual_texto = parent.master.text
        fase_actual = fase_actual_texto.split(' ')[0]
        if fase_actual not in self.entry_widgets_por_fase:
            self.entry_widgets_por_fase[fase_actual] = []
        self.entry_widgets_por_fase[fase_actual].append((local, visitante, goles_local, goles_visitante))

    def _mostrar_campeon(self):
        """Muestra una sección especial con el nombre del campeón del torneo."""
        ganador_final = logic.obtener_ganadores("Final")
        if ganador_final:
            frame_campeon = widgets.CollapsibleFrame(self.fases_container, text="Campeón del Torneo")
            frame_campeon.pack(pady=10, padx=10, fill="x")
            ttk.Separator(self.fases_container, orient='horizontal').pack(fill='x', padx=10, pady=5)
            inner_frame = ttk.Frame(frame_campeon.container, style='Champion.TFrame')
            inner_frame.pack(fill='x', expand=True, padx=10, pady=5)
            lbl_campeon = ttk.Label(inner_frame, text=f" {ganador_final[0]}", image=self.icon_medal, compound="left", font=("Arial", 16, "bold"), foreground="royalblue", background='#f0f0f0')
            lbl_campeon.pack(pady=15)
            self._actualizar_barra_estado(f"¡El campeón del torneo es {ganador_final[0]}!")

    def _configurar_grid_fase(self, frame_container):
        """Configura las columnas del grid para alinear los partidos en las fases eliminatorias."""
        frame_container.columnconfigure(0, weight=1) # Equipo local (se expande a la izquierda)
        frame_container.columnconfigure(1, weight=0) # Gol local (tamaño fijo)
        frame_container.columnconfigure(2, weight=0) # Separador "vs" (tamaño fijo)
        frame_container.columnconfigure(3, weight=0) # Gol visitante (tamaño fijo)
        frame_container.columnconfigure(4, weight=1) # Equipo visitante (se expande a la derecha)

    def registrar_fase_completa(self, fase):
        """
        Acción del botón 'Registrar Todos'. Valida y guarda todos los resultados
        de una fase eliminatoria de una sola vez.
        """
        partidos_info = self.entry_widgets_por_fase.get(fase, [])
        resultados_validados = []
        # Itera sobre cada partido y sus widgets de entrada.
        for i, (local, visitante, entry_local, entry_visitante) in enumerate(partidos_info):
            try:
                # Intenta convertir los valores a enteros.
                goles_local, goles_visitante = int(entry_local.get()), int(entry_visitante.get())
                # Valida que los goles no sean negativos.
                if goles_local < 0 or goles_visitante < 0:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Error de Validación", f"Resultado inválido en el partido {i+1} ({local} vs {visitante}).\nPor favor, ingrese solo números enteros no negativos.")
                return # Detiene la ejecución si hay un error.

            # Valida que no haya empates en fases eliminatorias.
            if goles_local == goles_visitante:
                messagebox.showerror("Error de Validación", f"Hay un empate en el partido {local} vs {visitante}.\nNo se permiten empates en fases eliminatorias.")
                return # Detiene la ejecución.

            # Si todas las validaciones pasan, añade el resultado a una lista temporal.
            resultados_validados.append((fase, local, visitante, goles_local, goles_visitante))

        # Solo si TODOS los resultados son válidos, procede a guardarlos.
        equipos_map = {nombre: id for id, nombre, zona, color in database.db.obtener_equipos()}
        for fase_db, local_db, visitante_db, gl_db, gv_db in resultados_validados:
            local_id, visitante_id = equipos_map.get(local_db), equipos_map.get(visitante_db)
            database.db.registrar_partido(fase_db, local_id, visitante_id, gl_db, gv_db)

        messagebox.showinfo("Éxito", f"Se han registrado todos los partidos de {fase}.")
        logger.warning(f"¡Fase '{fase}' completada y registrada!")
        # Actualiza la vista para mostrar la siguiente fase.
        self._actualizar_vista_eliminatorias()
        self._actualizar_barra_estado(f"Resultados de {fase} de Final registrados.")

lib\logic.py

"""
Módulo de Lógica del Torneo (Motor de Reglas)

Este archivo representa el "cerebro" del torneo. Contiene toda la lógica de
negocio y las reglas específicas para determinar el flujo de los partidos.
Es deliberadamente independiente de la interfaz gráfica y de los detalles
internos de la base de datos. Su única responsabilidad es procesar datos
y devolver resultados basados en las reglas del torneo.

Funciones clave:
- generar_fixture_zona: Crea los enfrentamientos para la fase de grupos.
- generar_enfrentamientos_iniciales: Genera los cruces de la primera fase eliminatoria.
- obtener_ganadores: Determina los equipos que avanzan de una fase eliminatoria.
- generar_enfrentamientos: Crea los partidos para las siguientes fases eliminatorias.
"""

# Se importa 'random' para poder barajar (shuffle) a los ganadores de una fase,
# asegurando que los siguientes enfrentamientos sean aleatorios.
import random

# Se importa 'itertools' específicamente por su función 'combinations', que es
# extremadamente eficiente para generar todos los pares únicos de un grupo
# (perfecto para un fixture de "todos contra todos").
import itertools

# Se importa el módulo 'database' completo para poder acceder a su instancia
# compartida 'db'. Esto es crucial para que los tests puedan reemplazarla.
from . import database

# Se importa el módulo de configuración para acceder a las reglas del torneo,
# como la lista de zonas y cuántos equipos clasifican.
from . import config

# Se importa el logger para registrar información sobre el progreso de la lógica.
from .logger import logger


def generar_fixture_zona(zona):
    """
    Genera la lista de partidos pendientes para una zona específica en la fase de grupos.

    Esta función implementa la lógica de "todos contra todos". Primero, calcula
    todos los enfrentamientos posibles entre los equipos de la zona. Luego, consulta
    la base de datos para ver qué partidos ya se han jugado y los excluye,
    devolviendo únicamente los que quedan por disputar.

    Args:
        zona (str): El nombre de la zona para la cual generar el fixture (ej: "A").

    Returns:
        list: Una lista de tuplas, donde cada tupla representa un partido
              pendiente con los nombres de los dos equipos.
    """
    # 1. Obtener todos los equipos que pertenecen a la zona especificada.
    database.db.cursor.execute("SELECT nombre FROM equipos WHERE zona = ?", (zona,))
    equipos_db = database.db.cursor.fetchall()
    # Extraer solo los nombres de los equipos de los resultados de la consulta.
    equipos_nombres = [equipo[0] for equipo in equipos_db]

    # 2. Obtener todos los partidos de fase de grupos que ya han sido registrados
    #    para esta zona. Es una consulta más compleja que une las tablas 'partidos'
    #    y 'equipos' para obtener los nombres de los participantes.
    database.db.cursor.execute("""
        SELECT el.nombre, ev.nombre
        FROM partidos p
        JOIN equipos el ON p.equipo_local_id = el.id
        JOIN equipos ev ON p.equipo_visitante_id = ev.id
        WHERE p.fase = 'Grupo' AND el.zona = ?
    """, (zona,))
    partidos_jugados_db = database.db.cursor.fetchall()

    # 3. Procesar los partidos jugados para una búsqueda eficiente.
    #    Se convierte la lista a un 'set' porque la comprobación de pertenencia
    #    (ej: `if x in my_set`) es mucho más rápida (O(1)) que en una lista (O(n)).
    #    Además, se "normaliza" cada partido ordenando los nombres de los equipos.
    #    Esto asegura que ('Equipo A', 'Equipo B') y ('Equipo B', 'Equipo A') se
    #    traten como el mismo partido, independientemente de la localía.
    partidos_jugados_set = {tuple(sorted(partido)) for partido in partidos_jugados_db}

    # 4. Generar todos los enfrentamientos posibles ("todos contra todos").
    #    `itertools.combinations` crea pares únicos de todos los equipos.
    #    Por ejemplo, para [A, B, C], genera (A, B), (A, C), (B, C).
    fixture_completo = list(itertools.combinations(equipos_nombres, 2))

    # 5. Filtrar el fixture para obtener solo los partidos pendientes.
    partidos_pendientes = []
    for partido in fixture_completo:
        # Para cada posible partido, se normaliza (ordena) y se comprueba si
        # ya está en el set de partidos jugados.
        if tuple(sorted(partido)) not in partidos_jugados_set:
            # Si no se ha jugado, se añade a la lista de pendientes.
            partidos_pendientes.append(partido)

    return partidos_pendientes

def generar_enfrentamientos_iniciales():
    """
    Genera los enfrentamientos para la primera fase eliminatoria (ej: Octavos de Final).

    Esta función sigue la regla de negocio específica de un cruce entre zonas.
    Primero, obtiene la tabla de posiciones final de cada zona. Luego, empareja
    a los equipos según un esquema cruzado (ej: 1° de Zona A vs. último clasificado
    de Zona B, 2° de Zona A vs. penúltimo de Zona B, y así sucesivamente).

    Returns:
        list or None: Una lista de tuplas con los enfrentamientos, o None si no
                      hay suficientes equipos clasificados para generar los cruces.
    """
    logger.info("Generando enfrentamientos iniciales (Octavos de Final)...")
    clasificados_por_zona = {}

    # Itera sobre cada zona definida en el archivo de configuración.
    for zona in config.ZONAS_DEL_TORNEO:
        # Llama al método de la base de datos para obtener la tabla de posiciones
        # ya calculada y ordenada para la zona actual.
        tabla = database.db.calcular_tabla_posiciones(zona)

        # Medida de seguridad: si no hay suficientes equipos en la tabla para
        # cumplir con el número de clasificados, la lógica no puede continuar.
        if len(tabla) < config.EQUIPOS_CLASIFICAN_POR_ZONA:
            logger.error(f"No hay suficientes equipos en la Zona {zona} para clasificar.")
            return None

        # Extrae los nombres de los equipos que clasificaron.
        # Se usa slicing `[:NUMERO]` para tomar solo los N primeros de la tabla.
        clasificados_por_zona[zona] = [equipo['nombre'] for equipo in tabla[:config.EQUIPOS_CLASIFICAN_POR_ZONA]]
        logger.debug(f"Clasificados de Zona {zona}: {clasificados_por_zona[zona]}")

    # --- LÓGICA DE EMPAREJAMIENTO CRUZADO ---
    # Esta es una regla de negocio específica para un torneo de 2 zonas.
    # Si el torneo se expandiera a 4 zonas, esta sección necesitaría ser modificada.
    if len(config.ZONAS_DEL_TORNEO) != 2:
        logger.error("La lógica de emparejamiento actual solo soporta 2 zonas.")
        return []

    # Se extraen los nombres de las zonas y las listas de equipos para mayor claridad.
    zona_a = config.ZONAS_DEL_TORNEO[0]
    zona_b = config.ZONAS_DEL_TORNEO[1]
    equipos_a = clasificados_por_zona[zona_a]
    equipos_b = clasificados_por_zona[zona_b]

    enfrentamientos = []
    num_clasificados = config.EQUIPOS_CLASIFICAN_POR_ZONA

    # Itera N veces, donde N es el número de equipos que clasifican por zona.
    for i in range(num_clasificados):
        # El equipo de la Zona A se toma en orden ascendente de clasificación.
        # Para i=0, es el 1er clasificado (equipos_a[0]).
        equipo_a = equipos_a[i]

        # El equipo de la Zona B se toma en orden descendente de clasificación.
        # La fórmula `(num_clasificados - 1) - i` logra el cruce:
        # - Cuando i=0 (1° de A), se enfrenta a equipos_b[N-1] (el último clasificado de B).
        # - Cuando i=1 (2° de A), se enfrenta a equipos_b[N-2] (el penúltimo de B).
        equipo_b = equipos_b[(num_clasificados - 1) - i]

        # Se crea la tupla del enfrentamiento y se añade a la lista.
        enfrentamiento = (equipo_a, equipo_b)
        enfrentamientos.append(enfrentamiento)
        logger.debug(f"Enfrentamiento generado: {equipo_a} (Pos {i+1}{zona_a}) vs {equipo_b} (Pos {num_clasificados-i}{zona_b})")

    return enfrentamientos

def obtener_ganadores(fase_anterior):
    """
    Consulta la base de datos para obtener la lista de equipos ganadores de una fase.

    Después de obtener la lista, la baraja aleatoriamente (`shuffle`) para que el
    sorteo de la siguiente ronda sea imparcial y no dependa del orden en que
    se jugaron o guardaron los partidos.

    Args:
        fase_anterior (str): El nombre de la fase de la cual obtener los ganadores
                             (ej: "Octavos").

    Returns:
        list: Una lista con los nombres de los equipos ganadores, en orden aleatorio.
    """
    # Pide al módulo de base de datos todos los partidos de la fase especificada.
    partidos = database.db.obtener_partidos_fase(fase_anterior)
    ganadores = []

    # Itera sobre cada partido recuperado.
    for partido in partidos:
        # Para cada partido, realiza una consulta para encontrar el nombre del equipo
        # cuyo ID coincide con el 'ganador_id' del partido.
        database.db.cursor.execute("SELECT e.nombre FROM partidos p JOIN equipos e ON p.ganador_id = e.id WHERE p.id = ?", (partido[0],))
        ganador = database.db.cursor.fetchone()
        if ganador:
            ganadores.append(ganador[0])

    # ¡Paso crucial! Se baraja la lista de ganadores. Esto asegura que los
    # emparejamientos en la siguiente ronda (Cuartos, Semis) sean aleatorios.
    random.shuffle(ganadores)
    return ganadores

def generar_enfrentamientos(fase_anterior):
    """
    Genera los enfrentamientos para las fases eliminatorias subsecuentes
    (Cuartos, Semifinal, Final).

    Esta función es más simple que la inicial. Llama a `obtener_ganadores` para
    obtener una lista ya barajada de los equipos que avanzaron y simplemente
    los empareja en el orden en que están en esa lista.

    Args:
        fase_anterior (str): El nombre de la fase de la cual provienen los
                             ganadores (ej: "Octavos").

    Returns:
        list: Una lista de tuplas con los nuevos enfrentamientos.
    """
    # El primer paso es determinar quiénes avanzaron de la ronda anterior.
    ganadores = obtener_ganadores(fase_anterior)

    # Si hay menos de dos ganadores, no se pueden formar partidos.
    if len(ganadores) < 2:
        return []

    enfrentamientos = []
    # Se utiliza un bucle `range` con un paso de 2 para tomar a los ganadores
    # de dos en dos (índices 0 y 1, luego 2 y 3, etc.).
    for i in range(0, len(ganadores), 2):
        # Se asegura de que haya un oponente para el equipo actual.
        if i + 1 < len(ganadores):
            # Se crea el par y se añade a la lista de enfrentamientos.
            enfrentamientos.append((ganadores[i], ganadores[i+1]))

    return enfrentamientos

lib\config.py

"""
Módulo de Configuración

Este archivo centraliza las constantes y parámetros de configuración de la
aplicación. Permite modificar el comportamiento del programa fácilmente sin
tener que cambiar la lógica principal.
"""

# --- CONFIGURACIÓN DE BOTONES DE PRUEBA ---
# Establecer en True para mostrar los botones de "Autogenerar".
# Establecer en False para ocultarlos en una versión "de producción".
BOTONES_PRUEBA_VISIBLES = True

# --- CONFIGURACIÓN DE LA ESTRUCTURA DEL TORNEO ---
# Define los nombres de las zonas/grupos. Puedes tener 2, 4, 8...
# Ejemplo para 4 zonas: ZONAS_DEL_TORNEO = ["A", "B", "C", "D"]
ZONAS_DEL_TORNEO = ["A", "B"]

# Define cuántos equipos por zona clasifican a la fase eliminatoria.
# El total de clasificados debe ser una potencia de 2 (4, 8, 16, 32...).
# Total = len(ZONAS_DEL_TORNEO) * EQUIPOS_CLASIFICAN_POR_ZONA
EQUIPOS_CLASIFICAN_POR_ZONA = 8

# Define el número máximo de equipos permitidos por zona.
# Esto previene que se agreguen equipos de más en la fase de gestión.
# Un valor común es el doble de los que clasifican.
MAX_EQUIPOS_POR_ZONA = EQUIPOS_CLASIFICAN_POR_ZONA * 2

# --- CONFIGURACIÓN DE LOGGING ---
# Establecer en True para mostrar logs detallados en la terminal.
# Establecer en False para una operación más silenciosa.
LOGGING_ACTIVADO = True

# --- CONFIGURACIÓN VISUAL ---
# Establecer en True para que los escudos de los equipos en las fases
# eliminatorias se muestren con el color único de cada equipo.
# Si es False, los escudos no se mostraran
ESCUDOS_VISIBLES = True

lib\database.py

"""
Módulo de Base de Datos (Capa de Persistencia)

Este archivo centraliza toda la interacción con la base de datos SQLite3.
Actúa como una capa de abstracción, de modo que el resto de la aplicación
(GUI, lógica) no necesita conocer el lenguaje SQL ni los detalles de cómo
se almacenan los datos. Simplemente llaman a los métodos de esta clase.

Responsabilidades principales:
- Establecer y cerrar la conexión con el archivo de la base de datos.
- Definir y crear el esquema de la base de datos (tablas y columnas).
- Proveer métodos para las operaciones CRUD (Crear, Leer, Actualizar, Borrar)
  sobre equipos, partidos y configuraciones.
- Contener la lógica compleja de consulta, como el cálculo de la tabla de posiciones.
"""

# Se importa 'sqlite3' para la interacción con la base de datos.
import sqlite3

# Se importa 'random' para la generación de colores hexadecimales únicos.
import random

# Se importa 'atexit' para registrar una función que se ejecutará automáticamente
# cuando el programa esté a punto de finalizar. Se usa para garantizar que la
# conexión a la base de datos siempre se cierre correctamente.
import atexit

# Se importa el logger para registrar eventos importantes de la base de datos.
from .logger import logger

# Constante que define el nombre del archivo de la base de datos.
# Centralizarlo aquí facilita cambiarlo si fuera necesario.
DB_NAME = "torneo.sqlite3"


# --- Clase Principal de la Base de Datos ---
class Database:
    """
    Gestiona la conexión y todas las operaciones con la base de datos del torneo.
    Esta clase sigue el patrón Singleton (a través de la instancia única 'db'
    creada al final del archivo), asegurando que toda la aplicación comparta
    la misma conexión a la base de datos.
    """

    def __init__(self, db_name=DB_NAME):
        """
        Constructor de la clase. Establece la conexión con la base de datos.

        Al instanciar esta clase, se conecta al archivo SQLite especificado
        (creándolo si no existe), obtiene un 'cursor' para ejecutar comandos,
        y llama al método que asegura que las tablas necesarias existan.
        También registra el método de cierre para que se ejecute al salir.

        Args:
            db_name (str): El nombre del archivo de la base de datos.
                           Permite especificar un nombre diferente para los tests
                           (ej: ':memory:' para una base de datos en RAM).
        """
        try:
            # Establece la conexión con el archivo de la base de datos.
            self.conn = sqlite3.connect(db_name)
            # Crea un objeto cursor, que es el que ejecuta las sentencias SQL.
            self.cursor = self.conn.cursor()
            # Llama al método para crear las tablas si no existen.
            self.crear_tablas()

            # Registra 'cerrar_conexion' para que se llame automáticamente al
            # finalizar el programa, evitando conexiones abiertas.
            atexit.register(self.cerrar_conexion)
            logger.info("Conexión a la base de datos establecida.")
        except Exception as e:
            # Si ocurre cualquier error durante la conexión, se registra como
            # crítico y se relanza la excepción para detener el programa.
            logger.critical(f"No se pudo conectar a la base de datos: {e}")
            raise e

    def cerrar_conexion(self):
        """
        Cierra la conexión activa con la base de datos.
        Es importante cerrar la conexión para liberar recursos y asegurar que
        todos los cambios se guarden correctamente en el archivo.
        """
        # Se comprueba si el objeto de conexión existe antes de intentar cerrarlo.
        if self.conn:
            self.conn.close()
            logger.info("Conexión a la base de datos cerrada.")

    def crear_tablas(self):
        """
        Define y ejecuta las sentencias SQL para crear el esquema de la base de datos.
        Utiliza "CREATE TABLE IF NOT EXISTS" para que solo se ejecute la primera
        vez o si el archivo de la base de datos es eliminado.
        """
        # --- Tabla de Equipos ---
        # Almacena la información de cada equipo participante.
        # - id: Clave primaria autoincremental, única para cada equipo.
        # - nombre: Nombre del equipo, debe ser único (UNIQUE).
        # - zona: Grupo al que pertenece el equipo (ej: "A").
        # - color_hex: Un color hexadecimal único para la UI.
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS equipos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre TEXT NOT NULL UNIQUE,
            zona TEXT NOT NULL,
            color_hex TEXT NOT NULL UNIQUE
        )
        """)

        # --- Tabla de Partidos ---
        # Almacena cada partido jugado en el torneo.
        # - fase: Etapa del torneo (ej: "Grupo", "Octavos").
        # - equipo_local/visitante_id: Claves foráneas que referencian el 'id' de la tabla 'equipos'.
        # - ganador_id: También referencia el 'id' de la tabla 'equipos'. Es NULL en caso de empate.
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS partidos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            fase TEXT NOT NULL,
            equipo_local_id INTEGER,
            equipo_visitante_id INTEGER,
            goles_local INTEGER,
            goles_visitante INTEGER,
            ganador_id INTEGER,
            FOREIGN KEY (equipo_local_id) REFERENCES equipos (id),
            FOREIGN KEY (equipo_visitante_id) REFERENCES equipos (id),
            FOREIGN KEY (ganador_id) REFERENCES equipos (id)
        )
        """)

        # --- Tabla de Configuración ---
        # Almacena pares de llave-valor para guardar el estado del torneo.
        # - llave: El nombre de la configuración (ej: 'equipos_bloqueados').
        # - valor: El valor de esa configuración.
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS config (
            llave TEXT PRIMARY KEY,
            valor TEXT NOT NULL
        )""")

        # Confirma y guarda todos los cambios realizados en esta transacción.
        self.conn.commit()
        logger.debug("Estructura de la base de datos verificada/creada.")

    def borrar_todos_los_datos(self):
        """
        Elimina todos los registros de todas las tablas. Es una operación
        destructiva utilizada para reiniciar el torneo por completo.
        """
        logger.warning("Iniciando borrado total de la base de datos...")
        # Se usan sentencias DELETE sin WHERE para borrar todo el contenido.
        self.cursor.execute("DELETE FROM partidos")
        self.cursor.execute("DELETE FROM equipos")
        self.cursor.execute("DELETE FROM config")
        self.conn.commit()
        logger.info("Todos los datos han sido eliminados de la base de datos.")

    def obtener_config(self, llave, valor_por_defecto=None):
        """
        Obtiene un valor de la tabla de configuración.

        Args:
            llave (str): La configuración a buscar.
            valor_por_defecto: El valor a devolver si la llave no se encuentra.

        Returns:
            str or None: El valor encontrado o el valor por defecto.
        """
        self.cursor.execute("SELECT valor FROM config WHERE llave = ?", (llave,))
        resultado = self.cursor.fetchone()
        # El operador ternario devuelve el primer elemento de la tupla si
        # `resultado` no es None, de lo contrario devuelve `valor_por_defecto`.
        return resultado[0] if resultado else valor_por_defecto

    def establecer_config(self, llave, valor):
        """
        Guarda o actualiza un valor en la tabla de configuración.
        Utiliza "INSERT OR REPLACE" que inserta una nueva fila si la llave
        no existe, o reemplaza la fila existente si ya existe.

        Args:
            llave (str): La configuración a establecer.
            valor (any): El valor a guardar (se convierte a string).
        """
        self.cursor.execute("INSERT OR REPLACE INTO config (llave, valor) VALUES (?, ?)", (llave, str(valor)))
        self.conn.commit()
        logger.info(f"Configuración actualizada: '{llave}' = '{valor}'")

    # --- Métodos de conveniencia para configuraciones comunes ---
    def fase_grupos_bloqueada(self):
        """Comprueba si la fase de grupos está bloqueada, devolviendo True o False."""
        return self.obtener_config('fase_grupos_bloqueada') == '1'

    def equipos_bloqueados(self):
        """Comprueba si la gestión de equipos está bloqueada, devolviendo True o False."""
        return self.obtener_config('equipos_bloqueados') == '1'

    def _generar_color_unico(self):
        """
        Genera un color hexadecimal aleatorio y verifica que no esté ya en uso.
        El prefijo '_' indica que es un método "privado", pensado para ser
        usado solo por otros métodos dentro de esta misma clase.
        """
        while True:
            # Genera un color aleatorio en formato #RRGGBB.
            color = f"#{random.randint(0, 0xFFFFFF):06x}"
            # Consulta la base de datos para ver si este color ya existe.
            self.cursor.execute("SELECT id FROM equipos WHERE color_hex = ?", (color,))
            # Si `fetchone()` devuelve None, significa que el color no se encontró y es único.
            if self.cursor.fetchone() is None:
                return color

    def agregar_equipo(self, nombre, zona):
        """
        Inserta un nuevo equipo en la base de datos con un color único.
        Maneja posibles errores de integridad (nombres duplicados).

        Returns:
            bool: True si el equipo se agregó con éxito, False en caso contrario.
        """
        try:
            # Primero, obtiene un color que no esté repetido.
            color = self._generar_color_unico()
            # Ejecuta la inserción.
            self.cursor.execute("INSERT INTO equipos (nombre, zona, color_hex) VALUES (?, ?, ?)", (nombre, zona, color))
            self.conn.commit()
            logger.info(f"Equipo '{nombre}' agregado a Zona '{zona}' con color {color}.")
            return True
        except sqlite3.IntegrityError:
            # Este bloque se ejecuta si la inserción viola una restricción
            # UNIQUE (en este caso, el nombre del equipo).
            logger.error(f"Error al agregar: El equipo '{nombre}' ya existe.")
            return False

    def obtener_equipos(self):
        """Obtiene una lista de todos los equipos, ordenados por zona y nombre."""
        self.cursor.execute("SELECT id, nombre, zona, color_hex FROM equipos ORDER BY zona, nombre")
        return self.cursor.fetchall()

    def eliminar_equipo(self, equipo_id):
        """Elimina un equipo de la base de datos usando su ID."""
        self.cursor.execute("DELETE FROM equipos WHERE id = ?", (equipo_id,))
        self.conn.commit()
        logger.info(f"Equipo con ID '{equipo_id}' eliminado.")

    def actualizar_equipo(self, equipo_id, nuevo_nombre, nueva_zona):
        """
        Actualiza el nombre y la zona de un equipo existente.
        Maneja errores si el nuevo nombre ya está en uso.

        Returns:
            bool: True si la actualización fue exitosa, False si no.
        """
        try:
            self.cursor.execute("UPDATE equipos SET nombre = ?, zona = ? WHERE id = ?", (nuevo_nombre, nueva_zona, equipo_id))
            self.conn.commit()
            logger.info(f"Equipo con ID '{equipo_id}' actualizado a: Nombre='{nuevo_nombre}', Zona='{nueva_zona}'.")
            return True
        except sqlite3.IntegrityError:
            logger.error(f"Error al actualizar: El nombre '{nuevo_nombre}' ya está en uso.")
            return False

    def registrar_partido(self, fase, equipo_local_id, equipo_visitante_id, goles_local, goles_visitante):
        """
        Guarda el resultado de un partido en la base de datos.
        Calcula automáticamente el ID del ganador basado en los goles.
        """
        ganador_id = None  # Por defecto, es un empate.
        if goles_local > goles_visitante:
            ganador_id = equipo_local_id
        elif goles_visitante > goles_local:
            ganador_id = equipo_visitante_id

        self.cursor.execute("""
        INSERT INTO partidos (fase, equipo_local_id, equipo_visitante_id, goles_local, goles_visitante, ganador_id)
        VALUES (?, ?, ?, ?, ?, ?)
        """, (fase, equipo_local_id, equipo_visitante_id, goles_local, goles_visitante, ganador_id))
        self.conn.commit()
        logger.info(f"Partido de '{fase}' registrado: ID_Local={equipo_local_id} vs ID_Visitante={equipo_visitante_id} ({goles_local}-{goles_visitante}).")

    def obtener_partido_por_equipos(self, fase, local_id, visitante_id):
        """
        Busca un partido específico entre dos equipos en una fase determinada.
        Útil para saber si un partido ya ha sido jugado.
        """
        # La cláusula WHERE comprueba ambas combinaciones de localía.
        self.cursor.execute("""
            SELECT id, goles_local, goles_visitante FROM partidos
            WHERE fase = ? AND ((equipo_local_id = ? AND equipo_visitante_id = ?) OR (equipo_local_id = ? AND equipo_visitante_id = ?))
        """, (fase, local_id, visitante_id, visitante_id, local_id))
        return self.cursor.fetchone()

    def actualizar_partido(self, partido_id, goles_local, goles_visitante, ganador_id):
        """Actualiza el resultado de un partido que ya existe en la base de datos."""
        self.cursor.execute("""
            UPDATE partidos SET goles_local = ?, goles_visitante = ?, ganador_id = ?
            WHERE id = ?
        """, (goles_local, goles_visitante, ganador_id, partido_id))
        self.conn.commit()
        logger.info(f"Resultado del partido ID '{partido_id}' actualizado a {goles_local}-{goles_visitante}.")

    def obtener_partidos_fase(self, fase):
        """
        Obtiene una lista de todos los partidos jugados en una fase específica,
        incluyendo los nombres de los equipos en lugar de solo sus IDs.
        """
        # Se utilizan JOINs para cruzar la tabla de partidos con la de equipos
        # (dos veces, una para el local y otra para el visitante).
        self.cursor.execute("""
        SELECT p.id, el.nombre, ev.nombre, p.goles_local, p.goles_visitante
        FROM partidos p
        JOIN equipos el ON p.equipo_local_id = el.id
        JOIN equipos ev ON p.equipo_visitante_id = ev.id
        WHERE p.fase = ?
        """, (fase,))
        return self.cursor.fetchall()

    def reiniciar_fase_grupos(self):
        """Borra únicamente los partidos pertenecientes a la fase de grupos."""
        self.cursor.execute("DELETE FROM partidos WHERE fase = 'Grupo'")
        self.conn.commit()
        logger.warning("Resultados de la fase de grupos han sido reiniciados.")

    def reiniciar_fases_eliminatorias(self):
        """Borra únicamente los partidos que NO pertenecen a la fase de grupos."""
        # Esta consulta elimina todos los registros de la tabla 'partidos'
        # cuya fase sea diferente a 'Grupo', reseteando así Octavos, Cuartos, etc.
        self.cursor.execute("DELETE FROM partidos WHERE fase != 'Grupo'")
        self.conn.commit()
        logger.warning("Resultados de las fases eliminatorias han sido reiniciados.")

    def calcular_tabla_posiciones(self, zona):
        """
        Calcula y devuelve la tabla de posiciones completa para una zona.
        Este es el método más complejo, ya que realiza múltiples consultas a la
        base de datos para agregar los datos de cada equipo.

        Args:
            zona (str): La zona para la cual se calculará la tabla.

        Returns:
            list: Una lista de diccionarios, donde cada diccionario representa
                  una fila de la tabla de posiciones para un equipo.
        """
        # 1. Obtener todos los equipos de la zona.
        self.cursor.execute("SELECT id, nombre FROM equipos WHERE zona = ?", (zona,))
        equipos = self.cursor.fetchall()
        tabla = []

        # 2. Iterar sobre cada equipo para calcular sus estadísticas.
        for equipo_id, nombre_equipo in equipos:
            # Partidos Jugados (PJ)
            self.cursor.execute("SELECT COUNT(*) FROM partidos WHERE (equipo_local_id = ? OR equipo_visitante_id = ?) AND fase = 'Grupo'", (equipo_id, equipo_id))
            pj = self.cursor.fetchone()[0]
            # Partidos Ganados (PG)
            self.cursor.execute("SELECT COUNT(*) FROM partidos WHERE ganador_id = ? AND fase = 'Grupo'", (equipo_id,))
            pg = self.cursor.fetchone()[0]
            # Partidos Empatados (PE)
            self.cursor.execute("SELECT COUNT(*) FROM partidos WHERE (equipo_local_id = ? OR equipo_visitante_id = ?) AND goles_local = goles_visitante AND fase = 'Grupo'", (equipo_id, equipo_id))
            pe = self.cursor.fetchone()[0]
            # Partidos Perdidos (PP) se calcula a partir de los otros valores.
            pp = pj - pg - pe
            # Goles a Favor (GF)
            self.cursor.execute("SELECT SUM(goles_local) FROM partidos WHERE equipo_local_id = ? AND fase = 'Grupo'", (equipo_id,))
            gf_local = self.cursor.fetchone()[0] or 0 # 'or 0' para manejar casos de SUM sobre 0 filas (que devuelve None)
            self.cursor.execute("SELECT SUM(goles_visitante) FROM partidos WHERE equipo_visitante_id = ? AND fase = 'Grupo'", (equipo_id,))
            gf_visitante = self.cursor.fetchone()[0] or 0
            gf = gf_local + gf_visitante
            # Goles en Contra (GC)
            self.cursor.execute("SELECT SUM(goles_visitante) FROM partidos WHERE equipo_local_id = ? AND fase = 'Grupo'", (equipo_id,))
            gc_local = self.cursor.fetchone()[0] or 0
            self.cursor.execute("SELECT SUM(goles_local) FROM partidos WHERE equipo_visitante_id = ? AND fase = 'Grupo'", (equipo_id,))
            gc_visitante = self.cursor.fetchone()[0] or 0
            gc = gc_local + gc_visitante
            # Diferencia de Goles (DG)
            dg = gf - gc
            # Puntos (3 por victoria, 1 por empate)
            puntos = (pg * 3) + pe

            # 3. Construir un diccionario con todas las estadísticas del equipo.
            tabla.append({
                "nombre": nombre_equipo, "pj": pj, "pg": pg, "pe": pe, "pp": pp,
                "gf": gf, "gc": gc, "dg": dg, "puntos": puntos
            })

        # 4. Ordenar la tabla según los criterios de desempate.
        #    Se ordena primero por Puntos, luego por Diferencia de Goles, y finalmente
        #    por Goles a Favor. `reverse=True` para que sea de mayor a menor.
        tabla.sort(key=lambda x: (x['puntos'], x['dg'], x['gf']), reverse=True)
        return tabla

# --- Instancia Única (Singleton) ---
# Se crea una única instancia de la clase Database cuando este módulo es importado.
# El resto de la aplicación (gui.py, logic.py) importará esta variable 'db'
# para asegurarse de que todos los componentes compartan la misma conexión.
db = Database()

lib\widgets.py

"""
Módulo de Widgets Personalizados (Componentes Reutilizables de GUI)

Este archivo contiene clases que extienden la funcionalidad base de Tkinter
para crear componentes de interfaz gráfica (widgets) a medida. El objetivo
principal es encapsular funcionalidades complejas y repetitivas de la GUI
en clases autocontenidas y reutilizables.

Esto sigue el principio de "No te repitas" (Don't Repeat Yourself - DRY)
y ayuda a que el código del módulo principal de la GUI (`gui.py`) sea
mucho más limpio, legible y fácil de mantener, ya que puede instanciar
estos widgets complejos con una sola línea de código.

Widgets definidos:
- Tooltip: Una clase que añade mensajes emergentes (tooltips) a cualquier widget.
- CollapsibleFrame: Un widget de tipo "acordeón" que puede mostrar y ocultar
  su contenido, ideal para organizar la información verticalmente.
"""

# Se importa la librería `tkinter` completa como 'tk' para los componentes base.
import tkinter as tk

# Se importa el submódulo `ttk` que contiene los widgets temáticos y de
# apariencia más moderna.
from tkinter import ttk


# --- Clase Auxiliar para Crear Tooltips ---
class Tooltip:
    """
    Crea un mensaje emergente (tooltip) para un widget de Tkinter.

    Esta clase no es un widget en sí misma, sino una clase "ayudante" que se
    asocia a un widget existente. Se encarga de escuchar los eventos del ratón
    (cuando entra y sale del área del widget) para mostrar y ocultar una pequeña
    ventana con texto informativo.
    """

    def __init__(self, widget, text):
        """
        Inicializa el tooltip y lo asocia a un widget.

        Args:
            widget (tk.Widget): El widget al cual se le añadirá el tooltip.
            text (str): El texto que se mostrará en el mensaje emergente.
        """
        # Guarda una referencia al widget "padre" y al texto.
        self.widget = widget
        self.text = text
        self.tooltip_window = None  # Inicialmente, no hay ninguna ventana de tooltip.

        # --- Manejo de Eventos ---
        # `bind` asocia un evento a una función (callback).
        # Cuando el cursor del ratón entra en el área del widget, se llama a `show_tooltip`.
        self.widget.bind("<Enter>", self.show_tooltip)
        # Cuando el cursor del ratón sale del área del widget, se llama a `hide_tooltip`.
        self.widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event):
        """

        Crea y muestra la ventana del tooltip cerca del cursor del ratón.
        Esta función es el "callback" que se ejecuta con el evento <Enter>.

        Args:
            event: El objeto de evento de Tkinter (no se usa directamente,
                   pero es requerido por la firma de la función `bind`).
        """
        # Pide al widget las coordenadas de su "caja" (bounding box).
        x, y, _, _ = self.widget.bbox("insert")
        # Convierte las coordenadas locales del widget a coordenadas globales de la pantalla.
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25

        # Crea una nueva ventana de nivel superior (`Toplevel`), que es una
        # ventana independiente sin los controles estándar (minimizar, cerrar, etc.).
        self.tooltip_window = tk.Toplevel(self.widget)
        # `wm_overrideredirect(True)` elimina los bordes y la barra de título de la ventana.
        self.tooltip_window.wm_overrideredirect(True)
        # Posiciona la ventana en las coordenadas calculadas.
        self.tooltip_window.wm_geometry(f"+{x}+{y}")

        # Crea una etiqueta (Label) dentro de la ventana del tooltip para mostrar el texto.
        label = tk.Label(self.tooltip_window, text=self.text, justify='left',
                         background="#ffffe0", relief='solid', borderwidth=1,
                         font=("tahoma", "8", "normal"))
        label.pack(ipadx=1)

    def hide_tooltip(self, event):
        """
        Destruye la ventana del tooltip.
        Esta función es el "callback" que se ejecuta con el evento <Leave>.
        """
        # Si la ventana del tooltip existe, destrúyela.
        if self.tooltip_window:
            self.tooltip_window.destroy()
        # Restablece la variable a None para indicar que ya no hay un tooltip visible.
        self.tooltip_window = None


# --- Widget Personalizado: Frame Colapsable (Acordeón) ---
class CollapsibleFrame(ttk.Frame):
    """
    Un widget que consiste en un Frame de `ttk` que puede ser expandido o
    colapsado por el usuario haciendo clic en un botón en su cabecera.

    Hereda de `ttk.Frame`, por lo que se puede usar como cualquier otro frame
    para contener otros widgets. La diferencia es que encapsula la lógica
    para mostrar u ocultar su contenido.
    """

    def __init__(self, parent, text="", expanded=True):
        """
        Inicializa el Frame colapsable.

        Args:
            parent (tk.Widget): El widget maestro que contendrá este frame.
            text (str): El texto del título que aparecerá en la cabecera.
            expanded (bool): El estado inicial del widget (expandido o colapsado).
        """
        # Llama al constructor de la clase padre (ttk.Frame).
        super().__init__(parent)

        # Guarda las propiedades iniciales.
        self.text = text
        self._expanded = expanded  # Se usa '_' para indicar que es una variable "privada".

        # --- Construcción de la Cabecera ---
        # La cabecera es un frame interno que contiene el botón de despliegue y el título.
        self.header_frame = ttk.Frame(self)
        self.header_frame.pack(fill="x", expand=True, pady=(0, 2))

        # El botón de despliegue (toggle) muestra una flecha que cambia de dirección.
        # Su `command` está asociado al método `toggle` de esta misma clase.
        self.toggle_button = ttk.Button(self.header_frame, text="▼" if expanded else "▶",
                                        width=3, command=self.toggle)
        self.toggle_button.pack(side="left")

        # La etiqueta que muestra el título del frame.
        ttk.Label(self.header_frame, text=self.text, font=("Arial", 10, "bold")).pack(side="left", padx=5)

        # --- Construcción del Contenedor ---
        # Este es el frame que se mostrará u ocultará.
        # Otros widgets (botones, etiquetas, etc.) se deben añadir a ESTE `container`,
        # no directamente al `CollapsibleFrame`.
        self.container = ttk.Frame(self, style='Content.TFrame', padding=10)

        # Si el estado inicial es expandido, se muestra el contenedor.
        if self._expanded:
            self.container.pack(fill="x", expand=True, padx=5, pady=(0, 5))

    def toggle(self):
        """
        Cambia el estado del frame entre expandido y colapsado.
        Este método es llamado por el `toggle_button`.
        """
        # Si el frame está actualmente expandido, lo colapsamos.
        if self._expanded:
            # `pack_forget()` oculta el widget sin destruirlo, manteniendo su
            # estado y contenido para cuando se vuelva a mostrar.
            self.container.pack_forget()
            # Cambia el texto del botón para indicar la acción de expandir.
            self.toggle_button.configure(text="▶")
        # Si el frame está actualmente colapsado, lo expandimos.
        else:
            # `pack()` vuelve a mostrar el widget en la ventana.
            self.container.pack(fill="x", expand=True, padx=5, pady=(0, 5))
            # Cambia el texto del botón para indicar la acción de colapsar.
            self.toggle_button.configure(text="▼")

        # Invierte el valor booleano del estado.
        self._expanded = not self._expanded

lib\logger.py

"""
Módulo de Configuración de Logging

Este archivo se encarga de una única tarea: configurar y proporcionar una
instancia centralizada del sistema de registro (logger) para toda la aplicación.
El uso de un logger es una práctica recomendada sobre el uso de `print()`
para la depuración, ya que permite:

- Asignar niveles de severidad a los mensajes (DEBUG, INFO, WARNING, ERROR).
- Formatear la salida de manera consistente.
- Activar o desactivar fácilmente toda la salida de depuración desde un
  único punto (el archivo de configuración).

La librería `colorlog` se utiliza para mejorar la legibilidad de los logs en
la terminal, asignando colores a cada nivel de severidad.
"""

# Se importa el módulo `logging` estándar de Python.
import logging

# Se importa `colorlog`, una librería externa que extiende `logging` para
# añadir color a la salida de la consola.
import colorlog

# Se importa el módulo de configuración para poder leer si el logging
# debe estar activado o no.
from . import config


def configurar_logger():
    """
    Crea, configura y devuelve un objeto logger para la aplicación.

    Esta función es el núcleo de la configuración. Comprueba el valor de
    `LOGGING_ACTIVADO` en el archivo `config.py`.
    - Si es `True`, configura un logger que imprime mensajes coloridos en la
      consola para todos los niveles a partir de DEBUG.
    - Si es `False`, configura un logger "silencioso" que no realiza ninguna
      acción, evitando así cualquier salida en la consola en un entorno de
      producción.

    Returns:
        logging.Logger: La instancia del logger configurada.
    """
    # Obtiene (o crea si no existe) un logger con el nombre "torneo_app".
    # Usar un nombre específico permite que toda la app comparta el mismo logger.
    log = logging.getLogger("torneo_app")

    # Condición principal: solo se configura el handler si el logging está
    # activado Y si el logger no tiene ya handlers configurados (esto evita
    # añadir handlers duplicados si la función se llamara varias veces).
    if config.LOGGING_ACTIVADO and not log.handlers:
        # Establece el nivel mínimo de severidad que el logger procesará.
        # `logging.DEBUG` es el nivel más bajo, por lo que capturará todo.
        log.setLevel(logging.DEBUG)

        # Crea un 'handler', que es el responsable de enviar los registros
        # a un destino. `StreamHandler` lo envía a la consola (terminal).
        handler = colorlog.StreamHandler()

        # Define el formato de cada línea de log.
        # - `%(log_color)s`: Inyecta el código de color para el nivel del mensaje.
        # - `%(levelname)-8s`: El nombre del nivel (ej: "INFO"), alineado a 8 caracteres.
        # - `%(reset)s`: Restablece el color.
        # - `%(blue)s%(message)s`: El mensaje del log en color azul.
        formatter = colorlog.ColoredFormatter(
            '%(log_color)s%(levelname)-8s%(reset)s %(blue)s%(message)s',
            # Mapea cada nivel de log a un color específico.
            log_colors={
                'DEBUG':    'cyan',
                'INFO':     'green',
                'WARNING':  'yellow',
                'ERROR':    'red',
                'CRITICAL': 'red,bg_white',
            }
        )

        # Asocia el formateador al handler.
        handler.setFormatter(formatter)
        # Asocia el handler al logger.
        log.addHandler(handler)

    # Si el logging está explícitamente desactivado en el archivo de configuración.
    elif not config.LOGGING_ACTIVADO:
        # Se añade un `NullHandler`, que es un "agujero negro" para los logs.
        # Recibe los mensajes de log pero no hace nada con ellos. Esto es más
        # eficiente que llenar el código de `if config.LOGGING_ACTIVADO:`
        # antes de cada llamada al logger.
        log.addHandler(logging.NullHandler())

    # Devuelve la instancia del logger, ya sea configurada o silenciosa.
    return log

# --- Instancia Única (Singleton) ---
# Se llama a la función de configuración UNA SOLA VEZ, cuando este módulo es
# importado por primera vez.
# La instancia resultante se guarda en la variable 'logger'.
# Otros módulos (gui.py, database.py, etc.) importarán esta variable
# para usar el mismo logger configurado en toda la aplicación.
logger = configurar_logger()

